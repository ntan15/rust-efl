extern crate libc;
extern crate eina_sys;
extern crate eo_sys;

use libc::*;
use eina_sys::*;
use eo_sys::*;

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct EcoreVersion {
    pub major: c_int,
    pub minor: c_int,
    pub micro: c_int,
    pub revision: c_int,
}

pub type EcoreTaskCb = Option<unsafe extern "C" fn(data: *mut c_void) -> EinaBool>;
pub type EcoreSelectFunction = Option<unsafe extern "C" fn(nfds: c_int, 
                                                             readfds: *mut fd_set,
                                                             writefds: *mut fd_set,
                                                             exceptfds: *mut fd_set,
                                                             timeout: *mut timeval)
                                                             -> c_int>;
pub type EcoreCb = Option<unsafe extern "C" fn(data: *mut c_void)>;
pub type EcoreDataCb = Option<unsafe extern "C" fn(data: *mut c_void) -> *mut c_void>;

pub enum EcoreWin32Handler { }
pub enum EcoreEventHandler { }
pub enum EcoreEventFilter { }
pub enum EcoreEvent { }
pub type EcoreFilterCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                       loop_data: *mut c_void,
                                                       _type: c_int, event: *mut c_void)
                                                       -> EinaBool>;
pub type EcoreEndCb = Option<unsafe extern "C" fn(user_data: *mut c_void,
                                                    func_data: *mut c_void)>;
pub type EcoreEventHandlerCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                            _type: c_int,
                                                            event: *mut c_void) -> EinaBool>;
#[repr(C)]
pub struct EcoreEventSignalUser {
    pub number: c_int,
    pub ext_data: *mut c_void,
    pub data: siginfo_t,
}

#[repr(C)]
pub struct EcoreEventSignalHup {
    pub ext_data: *mut c_void,
    pub data: siginfo_t,
}

#[repr(C)]
pub struct EcoreEventSignalExit {
    pub _bindgen_bitfield_1_: EinaBool,
    pub _bindgen_bitfield_2_: EinaBool,
    pub _bindgen_bitfield_3_: EinaBool,
    pub ext_data: *mut c_void,
    pub data: siginfo_t,
}

#[repr(C)]
pub struct EcoreEventSignalPower {
    pub ext_data: *mut c_void,
    pub data: siginfo_t,
}

#[repr(C)]
pub struct EcoreEventSignalRealtime {
    pub num: c_int,
    pub data: siginfo_t,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcoreMemoryState {
    EcoreMemoryStateNormal = 0,
    EcoreMemoryStateLow = 1,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcorePowerState {
    EcorePowerStateMains = 0,
    EcorePowerStateBattery = 1,
    EcorePowerStateLow = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcoreExeFlags {
    EcoreExeNone = 0,
    EcoreExePipeRead = 1,
    EcoreExePipeWrite = 2,
    EcoreExePipeError = 4,
    EcoreExePipeRead_Line_Buffered = 8,
    EcoreExePipeError_Line_Buffered = 16,
    EcoreExePipeAuto = 32,
    EcoreExeRespawn = 64,
    EcoreExeUseSh = 128,
    EcoreExeNotLeader = 256,
    EcoreExeTermWith_Parent = 512,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcoreExeWin32Priority {
    ECORE_EXE_WIN32_PRIORITY_IDLE = 0,
    ECORE_EXE_WIN32_PRIORITY_BELOW_NORMAL = 1,
    ECORE_EXE_WIN32_PRIORITY_NORMAL = 2,
    ECORE_EXE_WIN32_PRIORITY_ABOVE_NORMAL = 3,
    ECORE_EXE_WIN32_PRIORITY_HIGH = 4,
    ECORE_EXE_WIN32_PRIORITY_REALTIME = 5,
}

pub type EcoreExe = Eo;
pub type EcoreExeCb = Option<unsafe extern "C" fn(data: *mut c_void, exe: *const EcoreExe)>;

#[repr(C)]
pub struct EcoreExeEventAdd {
    pub exe: *mut EcoreExe,
    pub ext_data: *mut c_void,
}

#[repr(C)]
pub struct EcoreExeEventDel {
    pub pid: pid_t,
    pub exit_code: c_int,
    pub exe: *mut EcoreExe,
    pub exit_signal: c_int,
    pub _bindgen_bitfield_1_: EinaBool,
    pub _bindgen_bitfield_2_: EinaBool,
    pub ext_data: *mut c_void,
    pub data: siginfo_t,
}


#[repr(C)]
pub struct EcoreExeEventDataLine {
    pub line: *mut c_char,
    pub size: c_int,
}

#[repr(C)]
pub struct EcoreExeEventData {
    pub exe: *mut EcoreExe,
    pub data: *mut c_void,
    pub size: c_int,
    pub lines: *mut EcoreExeEventDataLine,
}

pub enum EcoreFdHandler { }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcoreFdHandlerFlags {
    EcoreFdRead = 1,
    EcoreFdWrite = 2,
    EcoreFdError = 4,
}

pub type EcoreFdCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                   fd_handler: *mut EcoreFdHandler)
                                                   -> EinaBool>;
pub type EcoreFdPrepCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                        fd_handler: *mut EcoreFdHandler)>;
pub type EcoreWin32HandleCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                             wh: *mut EcoreWin32Handler)
                                                             -> EinaBool>;
pub enum EcoreThread { }

pub type EcoreThreadCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                     thread: *mut EcoreThread)>;
pub type EcoreThreadNotifyCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                           thread: *mut EcoreThread,
                                                           msg_data: *mut c_void)>;
pub enum EcorePipe { }

pub type EcorePipeCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                   buffer: *mut c_void,
                                                   nbyte: c_uint)>;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcorePollerType { 
    EcorePollerCore = 0, 
    Dummy,
}

pub type EcorePoller = Eo;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcorePosMap {
    EcorePosMapLinear = 0,
    EcorePosMapAccelerate = 1,
    EcorePosMapDecelerate = 2,
    EcorePosMapSinusoidal = 3,
    EcorePosMapAccelerateFactor = 4,
    EcorePosMapDecelerateFactor = 5,
    EcorePosMapSinusoidalFactor = 6,
    EcorePosMapDivisorInterp = 7,
    EcorePosMapBounce = 8,
    EcorePosMapSpring = 9,
    EcorePosMapCubicBezier = 10,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EcoreAnimatorSource {
    EcoreAnimatorSourceTimer = 0,
    EcoreAnimatorSourceCustom = 1,
}

pub type EcoreTimelineCb = Option<unsafe extern "C" fn(data: *mut c_void, pos: c_double)
                                                       -> EinaBool>;
pub type EcoreAnimator = Eo;
pub type EcoreTimer = Eo;
pub type EcoreIdler = Eo;
pub type EcoreIdleEnterer = Eo;
pub type EcoreIdleExiter = Eo;
pub type EcoreJob = Eo;
pub type EcoreMainloop = Eo;

#[link(name = "ecore")]
extern "C" {
    pub static mut ecore_version: *mut EcoreVersion;
    pub static mut ECORE_EXE_EVENT_ADD: c_int;
    pub static mut ECORE_EXE_EVENT_DEL: c_int;
    pub static mut ECORE_EXE_EVENT_DATA: c_int;
    pub static mut ECORE_EXE_EVENT_ERROR: c_int;
// Eo
    pub static _ECORE_EXE_EVENT_DATA_GET: EoEventDescription;
    pub static _ECORE_EXE_EVENT_DATA_ERROR: EoEventDescription;
    pub static _ECORE_MAINLOOP_EVENT_IDLE_ENTER: EoEventDescription;
    pub static _ECORE_MAINLOOP_EVENT_IDLE_EXIT: EoEventDescription;
    pub static _ECORE_MAINLOOP_EVENT_IDLE: EoEventDescription;
}
#[link(name = "ecore")]
extern "C" {
//------------------------------------------------------------------------------------------------
// Ecore Common
//------------------------------------------------------------------------------------------------
    pub fn ecore_init() -> c_int;
    pub fn ecore_shutdown() -> c_int;
    pub fn ecore_main_loop_iterate();
    pub fn ecore_main_loop_iterate_may_block(may_block: c_int)
     -> c_int;
    pub fn ecore_main_loop_select_func_set(func: EcoreSelectFunction);
    pub fn ecore_main_loop_select_func_get() -> EcoreSelectFunction;
    pub fn ecore_main_loop_glib_integrate() -> EinaBool;
    pub fn ecore_main_loop_glib_always_integrate_disable();
    pub fn ecore_main_loop_begin();
    pub fn ecore_main_loop_quit();
    pub fn ecore_main_loop_animator_ticked_get() -> EinaBool;
    pub fn ecore_main_loop_nested_get() -> c_int;
    pub fn ecore_fork_reset_callback_add(func: EcoreCb,
                                         data: *const c_void)
     -> EinaBool;
    pub fn ecore_fork_reset_callback_del(func: EcoreCb,
                                         data: *const c_void)
     -> EinaBool;
    pub fn ecore_fork_reset();
    pub fn ecore_main_loop_thread_safe_call_async(callback: EcoreCb,
                                                  data:
                                                      *mut c_void);
    pub fn ecore_main_loop_thread_safe_call_sync(callback: EcoreDataCb,
                                                 data:
                                                     *mut c_void)
     -> *mut c_void;
    pub fn ecore_main_loop_thread_safe_call_wait(wait:
                                                     c_double);
    pub fn ecore_thread_main_loop_begin() -> c_int;
    pub fn ecore_thread_main_loop_end() -> c_int;
    pub fn ecore_event_handler_add(_type: c_int,
                                   func: EcoreEventHandlerCb,
                                   data: *const c_void)
     -> *mut EcoreEventHandler;
    pub fn ecore_event_handler_del(event_handler: *mut EcoreEventHandler)
     -> *mut c_void;
    pub fn ecore_event_add(_type: c_int,
                           ev: *mut c_void,
                           func_free: EcoreEndCb,
                           data: *mut c_void)
     -> *mut EcoreEvent;
    pub fn ecore_event_del(event: *mut EcoreEvent)
     -> *mut c_void;
    pub fn ecore_event_handler_data_get(eh: *mut EcoreEventHandler)
     -> *mut c_void;
    pub fn ecore_event_handler_data_set(eh: *mut EcoreEventHandler,
                                        data: *const c_void)
     -> *mut c_void;
    pub fn ecore_event_type_new() -> c_int;
    pub fn ecore_event_filter_add(func_start: EcoreDataCb,
                                  func_filter: EcoreFilterCb,
                                  func_end: EcoreEndCb,
                                  data: *const c_void)
     -> *mut EcoreEventFilter;
    pub fn ecore_event_filter_del(ef: *mut EcoreEventFilter)
     -> *mut c_void;
    pub fn ecore_event_current_type_get() -> c_int;
    pub fn ecore_event_current_event_get() -> *mut c_void;
    pub fn ecore_memory_state_get() -> EcoreMemoryState;
    pub fn ecore_memory_state_set(state: EcoreMemoryState);
    pub fn ecore_power_state_get() -> EcorePowerState;
    pub fn ecore_power_state_set(state: EcorePowerState);
    pub fn ecore_exe_run_priority_set(pri: c_int);
    pub fn ecore_exe_run_priority_get() -> c_int;
    pub fn ecore_exe_run(exe_cmd: *const c_char,
                         data: *const c_void)
     -> *mut EcoreExe;
    pub fn ecore_exe_pipe_run(exe_cmd: *const c_char,
                              flags: EcoreExeFlags,
                              data: *const c_void)
     -> *mut EcoreExe;
    pub fn ecore_exe_callback_pre_free_set(exe: *mut EcoreExe,
                                           func: EcoreExeCb);
    pub fn ecore_exe_send(exe: *mut EcoreExe,
                          data: *const c_void,
                          size: c_int) -> EinaBool;
    pub fn ecore_exe_close_stdin(exe: *mut EcoreExe);
    pub fn ecore_exe_auto_limits_set(exe: *mut EcoreExe,
                                     start_bytes: c_int,
                                     end_bytes: c_int,
                                     start_lines: c_int,
                                     end_lines: c_int);
    pub fn ecore_exe_event_data_get(exe: *mut EcoreExe,
                                    flags: EcoreExeFlags)
     -> *mut EcoreExeEventData;
    pub fn ecore_exe_event_data_free(data: *mut EcoreExeEventData);
    pub fn ecore_exe_free(exe: *mut EcoreExe) -> *mut c_void;
    pub fn ecore_exe_pid_get(exe: *const EcoreExe) -> pid_t;
    pub fn ecore_exe_tag_set(exe: *mut EcoreExe,
                             tag: *const c_char);
    pub fn ecore_exe_tag_get(exe: *const EcoreExe)
     -> *const c_char;
    pub fn ecore_exe_cmd_get(exe: *const EcoreExe)
     -> *const c_char;
    pub fn ecore_exe_data_get(exe: *const EcoreExe)
     -> *mut c_void;
    pub fn ecore_exe_data_set(exe: *mut EcoreExe,
                              data: *mut c_void)
     -> *mut c_void;
    pub fn ecore_exe_flags_get(exe: *const EcoreExe) -> EcoreExeFlags;
    pub fn ecore_exe_pause(exe: *mut EcoreExe);
    pub fn ecore_exe_continue(exe: *mut EcoreExe);
    pub fn ecore_exe_interrupt(exe: *mut EcoreExe);
    pub fn ecore_exe_quit(exe: *mut EcoreExe);
    pub fn ecore_exe_terminate(exe: *mut EcoreExe);
    pub fn ecore_exe_kill(exe: *mut EcoreExe);
    pub fn ecore_exe_signal(exe: *mut EcoreExe, num: c_int);
    pub fn ecore_exe_hup(exe: *mut EcoreExe);
    pub fn ecore_main_fd_handler_add(fd: c_int,
                                     flags: EcoreFdHandlerFlags,
                                     func: EcoreFdCb,
                                     data: *const c_void,
                                     buf_func: EcoreFdCb,
                                     buf_data: *const c_void)
     -> *mut EcoreFdHandler;
    pub fn ecore_main_fd_handler_file_add(fd: c_int,
                                          flags: EcoreFdHandlerFlags,
                                          func: EcoreFdCb,
                                          data: *const c_void,
                                          buf_func: EcoreFdCb,
                                          buf_data:
                                              *const c_void)
     -> *mut EcoreFdHandler;
    pub fn ecore_main_fd_handler_prepare_callback_set(fd_handler:
                                                          *mut EcoreFdHandler,
                                                      func: EcoreFdPrepCb,
                                                      data:
                                                          *const c_void);
    pub fn ecore_main_fd_handler_del(fd_handler: *mut EcoreFdHandler)
     -> *mut c_void;
    pub fn ecore_main_fd_handler_fd_get(fd_handler: *mut EcoreFdHandler)
     -> c_int;
    pub fn ecore_main_fd_handler_active_get(fd_handler: *mut EcoreFdHandler,
                                            flags: EcoreFdHandlerFlags)
     -> EinaBool;
    pub fn ecore_main_fd_handler_active_set(fd_handler: *mut EcoreFdHandler,
                                            flags: EcoreFdHandlerFlags);
    pub fn ecore_main_win32_handler_add(h: *mut c_void,
                                        func: EcoreWin32HandleCb,
                                        data: *const c_void)
     -> *mut EcoreWin32Handler;
    pub fn ecore_main_win32_handler_del(win32_handler:
                                            *mut EcoreWin32Handler)
     -> *mut c_void;
    pub fn ecore_time_get() -> c_double;
    pub fn ecore_time_unix_get() -> c_double;
    pub fn ecore_loop_time_get() -> c_double;
    pub fn ecore_loop_time_set(t: c_double);
    pub fn ecore_thread_run(func_blocking: EcoreThreadCb,
                            func_end: EcoreThreadCb,
                            func_cancel: EcoreThreadCb,
                            data: *const c_void)
     -> *mut EcoreThread;
    pub fn ecore_thread_feedback_run(func_heavy: EcoreThreadCb,
                                     func_notify: EcoreThreadNotifyCb,
                                     func_end: EcoreThreadCb,
                                     func_cancel: EcoreThreadCb,
                                     data: *const c_void,
                                     try_no_queue: EinaBool)
     -> *mut EcoreThread;
    pub fn ecore_thread_cancel(thread: *mut EcoreThread) -> EinaBool;
    pub fn ecore_thread_wait(thread: *mut EcoreThread,
                             wait: c_double) -> EinaBool;
    pub fn ecore_thread_check(thread: *mut EcoreThread) -> EinaBool;
    pub fn ecore_thread_feedback(thread: *mut EcoreThread,
                                 msg_data: *const c_void)
     -> EinaBool;
    pub fn ecore_thread_reschedule(thread: *mut EcoreThread) -> EinaBool;
    pub fn ecore_thread_active_get() -> c_int;
    pub fn ecore_thread_pending_get() -> c_int;
    pub fn ecore_thread_pending_feedback_get() -> c_int;
    pub fn ecore_thread_pending_total_get() -> c_int;
    pub fn ecore_thread_max_get() -> c_int;
    pub fn ecore_thread_max_set(num: c_int);
    pub fn ecore_thread_max_reset();
    pub fn ecore_thread_available_get() -> c_int;
    pub fn ecore_thread_local_data_add(thread: *mut EcoreThread,
                                       key: *const c_char,
                                       value: *mut c_void,
                                       cb: EinaFreeCb, direct: EinaBool)
     -> EinaBool;
    pub fn ecore_thread_local_data_set(thread: *mut EcoreThread,
                                       key: *const c_char,
                                       value: *mut c_void,
                                       cb: EinaFreeCb)
     -> *mut c_void;
    pub fn ecore_thread_local_data_find(thread: *mut EcoreThread,
                                        key: *const c_char)
     -> *mut c_void;
    pub fn ecore_thread_local_data_del(thread: *mut EcoreThread,
                                       key: *const c_char)
     -> EinaBool;
    pub fn ecore_thread_global_data_add(key: *const c_char,
                                        value: *mut c_void,
                                        cb: EinaFreeCb, direct: EinaBool)
     -> EinaBool;
    pub fn ecore_thread_global_data_set(key: *const c_char,
                                        value: *mut c_void,
                                        cb: EinaFreeCb)
     -> *mut c_void;
    pub fn ecore_thread_global_data_find(key: *const c_char)
     -> *mut c_void;
    pub fn ecore_thread_global_data_del(key: *const c_char)
     -> EinaBool;
    pub fn ecore_thread_global_data_wait(key: *const c_char,
                                         seconds: c_double)
     -> *mut c_void;
    pub fn ecore_pipe_add(handler: EcorePipeCb,
                          data: *const c_void)
     -> *mut EcorePipe;
    pub fn ecore_pipe_full_add(handler: EcorePipeCb,
                               data: *const c_void,
                               fd_read: c_int,
                               fd_write: c_int,
                               read_survive_fork: EinaBool,
                               write_survive_fork: EinaBool)
     -> *mut EcorePipe;
    pub fn ecore_pipe_del(p: *mut EcorePipe) -> *mut c_void;
    pub fn ecore_pipe_write(p: *mut EcorePipe,
                            buffer: *const c_void,
                            nbytes: c_uint) -> EinaBool;
    pub fn ecore_pipe_write_close(p: *mut EcorePipe);
    pub fn ecore_pipe_read_close(p: *mut EcorePipe);
    pub fn ecore_pipe_read_fd(p: *mut EcorePipe) -> c_int;
    pub fn ecore_pipe_write_fd(p: *mut EcorePipe) -> c_int;
    pub fn ecore_pipe_thaw(p: *mut EcorePipe);
    pub fn ecore_pipe_freeze(p: *mut EcorePipe);
    pub fn ecore_pipe_wait(p: *mut EcorePipe,
                           message_count: c_int,
                           wait: c_double)
     -> c_int;
    pub fn ecore_app_args_set(argc: c_int,
                              argv: *mut *const c_char);
    pub fn ecore_app_args_get(argc: *mut c_int,
                              argv: *mut *mut *mut c_char);
    pub fn ecore_app_restart();
    pub fn ecore_app_no_system_modules();
    pub fn ecore_throttle_adjust(amount: c_double);
    pub fn ecore_throttle_get() -> c_double;
    pub fn ecore_poller_poll_interval_set(_type: EcorePollerType,
                                          poll_time: c_double);
    pub fn ecore_poller_poll_interval_get(_type: EcorePollerType)
     -> c_double;
    pub fn ecore_animator_frametime_set(frametime: c_double);
    pub fn ecore_animator_frametime_get() -> c_double;
    pub fn ecore_animator_pos_map(pos: c_double,
                                  map: EcorePosMap,
                                  v1: c_double,
                                  v2: c_double)
     -> c_double;
    pub fn ecore_animator_pos_map_n(pos: c_double,
                                    map: EcorePosMap,
                                    v_size: c_int,
                                    v: *mut c_double)
     -> c_double;
    pub fn ecore_animator_source_set(source: EcoreAnimatorSource);
    pub fn ecore_animator_source_get() -> EcoreAnimatorSource;
    pub fn ecore_animator_custom_source_tick_begin_callback_set(func: EcoreCb,
                                                                data: *const c_void);
    pub fn ecore_animator_custom_source_tick_end_callback_set(func: EcoreCb,
                                                              data: *const c_void);
    pub fn ecore_animator_custom_tick();
    pub fn ecore_timer_precision_get() -> c_double;
    pub fn ecore_timer_precision_set(precision: c_double);
    pub fn ecore_timer_dump() -> *mut c_char;

//------------------------------------------------------------------------------------------------
// Ecore Legacy
//------------------------------------------------------------------------------------------------
    pub fn ecore_poller_add(_type: EcorePollerType,
                            interval: c_int,
                            func: EcoreTaskCb,
                            data: *const c_void)
     -> *mut EcorePoller;
    pub fn ecore_poller_del(poller: *mut EcorePoller)
     -> *mut c_void;
    pub fn ecore_poller_poller_interval_set(obj: *mut EcorePoller,
                                            interval: c_int)
     -> EinaBool;
    pub fn ecore_poller_poller_interval_get(obj: *const EcorePoller)
     -> c_int;
    pub fn ecore_animator_add(func: EcoreTaskCb,
                              data: *const c_void)
     -> *mut EcoreAnimator;
    pub fn ecore_animator_timeline_add(runtime: c_double,
                                       func: EcoreTimelineCb,
                                       data: *const c_void)
     -> *mut EcoreAnimator;
    pub fn ecore_animator_del(animator: *mut EcoreAnimator)
     -> *mut c_void;
    pub fn ecore_animator_freeze(animator: *mut EcoreAnimator);
    pub fn ecore_animator_thaw(animator: *mut EcoreAnimator);
    pub fn ecore_timer_add(_in: c_double, func: EcoreTaskCb,
                           data: *const c_void)
     -> *mut EcoreTimer;
    pub fn ecore_timer_loop_add(_in: c_double,
                                func: EcoreTaskCb,
                                data: *const c_void)
     -> *mut EcoreTimer;
    pub fn ecore_timer_del(timer: *mut EcoreTimer)
     -> *mut c_void;
    pub fn ecore_timer_freeze(timer: *mut EcoreTimer);
    pub fn ecore_timer_freeze_get(timer: *mut EcoreTimer) -> EinaBool;
    pub fn ecore_timer_thaw(timer: *mut EcoreTimer);
    pub fn ecore_timer_interval_set(obj: *mut EcoreTimer,
                                    _in: c_double);
    pub fn ecore_timer_interval_get(obj: *const EcoreTimer)
     -> c_double;
    pub fn ecore_timer_pending_get(obj: *const EcoreTimer)
     -> c_double;
    pub fn ecore_timer_reset(obj: *mut EcoreTimer);
    pub fn ecore_timer_delay(obj: *mut EcoreTimer,
                             add: c_double);
    pub fn ecore_idler_add(func: EcoreTaskCb,
                           data: *const c_void)
     -> *mut EcoreIdler;
    pub fn ecore_idler_del(idler: *mut EcoreIdler)
     -> *mut c_void;
    pub fn ecore_idle_enterer_add(func: EcoreTaskCb,
                                  data: *const c_void)
     -> *mut EcoreIdleEnterer;
    pub fn ecore_idle_enterer_before_add(func: EcoreTaskCb,
                                         data: *const c_void)
     -> *mut EcoreIdleEnterer;
    pub fn ecore_idle_enterer_del(idle_enterer: *mut EcoreIdleEnterer)
     -> *mut c_void;
    pub fn ecore_idle_exiter_add(func: EcoreTaskCb,
                                 data: *const c_void)
     -> *mut EcoreIdleExiter;
    pub fn ecore_idle_exiter_del(idle_exiter: *mut EcoreIdleExiter)
     -> *mut c_void;
    pub fn ecore_job_add(func: EcoreCb, data: *const c_void)
     -> *mut EcoreJob;
    pub fn ecore_job_del(obj: *mut EcoreJob) -> *mut c_void;

//------------------------------------------------------------------------------------------------
// Ecore Eo
//------------------------------------------------------------------------------------------------
    pub fn ecore_poller_class_get() -> *const EoClass;
    pub fn ecore_poller_interval_set(interval: c_int)
     -> EinaBool;
    pub fn ecore_poller_interval_get() -> c_int;
    pub fn ecore_poller_constructor(_type: EcorePollerType,
                                    interval: c_int,
                                    func: EcoreTaskCb,
                                    data: *const c_void);
    pub fn ecore_animator_class_get() -> *const EoClass;
    pub fn ecore_animator_timeline_constructor(runtime: c_double,
                                               func: EcoreTimelineCb,
                                               data: *const c_void);
    pub fn ecore_animator_constructor(func: EcoreTaskCb,
                                      data: *const c_void);
    pub fn ecore_timer_class_get() -> *const EoClass;
    pub fn ecore_obj_timer_interval_set(_in: c_double);
    pub fn ecore_obj_timer_interval_get() -> c_double;
    pub fn ecore_obj_timer_pending_get() -> c_double;
    pub fn ecore_obj_timer_loop_constructor(_in: c_double,
                                            func: EcoreTaskCb,
                                            data: *const c_void);
    pub fn ecore_obj_timer_constructor(_in: c_double,
                                       func: EcoreTaskCb,
                                       data: *const c_void);
    pub fn ecore_obj_timer_reset();
    pub fn ecore_obj_timer_delay(add: c_double);
    pub fn ecore_idler_class_get() -> *const EoClass;
    pub fn ecore_idler_constructor(func: EcoreTaskCb,
                                   data: *const c_void);
    pub fn ecore_idle_exiter_class_get() -> *const EoClass;
    pub fn ecore_idle_exiter_constructor(func: EcoreTaskCb,
                                         data: *const c_void);
    pub fn ecore_idle_enterer_class_get() -> *const EoClass;
    pub fn ecore_idle_enterer_before_constructor(func: EcoreTaskCb,
                                                 data: *const c_void);
    pub fn ecore_idle_enterer_after_constructor(func: EcoreTaskCb,
                                                data: *const c_void);
    pub fn ecore_exe_class_get() -> *const EoClass;
    pub fn ecore_obj_exe_command_set(exe_cmd: *const c_char,
                                     flags: EcoreExeFlags);
    pub fn ecore_obj_exe_command_get(exe_cmd: *mut *const c_char,
                                     flags: *mut EcoreExeFlags);
    pub fn ecore_job_class_get() -> *const EoClass;
    pub fn ecore_job_constructor(func: EcoreCb,
                                 data: *const c_void);
    pub fn ecore_mainloop_class_get() -> *const EoClass;
    pub fn ecore_mainloop_select_func_set(select_func: EcoreSelectFunction);
    pub fn ecore_mainloop_select_func_get() -> EcoreSelectFunction;
    pub fn ecore_mainloop_iterate();
    pub fn ecore_mainloop_iterate_may_block(may_block: c_int)
     -> c_int;
    pub fn ecore_mainloop_begin();
    pub fn ecore_mainloop_quit();
    pub fn ecore_mainloop_animator_ticked() -> EinaBool;
    pub fn ecore_main_loop_get() -> *mut Eo;
}
