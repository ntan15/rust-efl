extern crate libc;
extern crate efl_sys;
extern crate eo_sys;
extern crate eina_sys;
extern crate emile_sys;

use libc::*;
use efl_sys::*;
use eo_sys::*;
use eina_sys::*;
use emile_sys::*;

/* automatically generated by rust-bindgen */

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasModuleType {
    EvasModuleTypeEngine = 0,
    EvasModuleTypeImageLoader = 1,
    EvasModuleTypeImageSaver = 2,
    EvasModuleTypeObject = 3,
}

pub enum EvasModulePath { }
pub enum EvasModuleEngine { }
pub enum EvasModulePublic { }

#[repr(C)]
pub struct EvasModuleApi {
    pub version: c_int,
    pub name: *const c_char,
    pub author: *const c_char,
    pub func: EvasStructUnnamed1,
}

#[repr(C)]
pub struct EvasStructUnnamed1 {
    pub open: Option<unsafe extern "C" fn(arg1: *mut EvasModule)
                                        -> c_int>,
    pub close: Option<unsafe extern "C" fn(arg1: *mut EvasModule)>,
}

#[repr(C)]
pub struct EvasModule {
    pub definition: *const EvasModuleApi,
    pub functions: *mut c_void,
    pub id_engine: c_int,
    pub _ref: c_int,
    pub last_used: c_int,
    pub lock: EinaLock,
    pub _bindgen_bitfield_1_: c_uchar,
}

pub type EvasImageLoadOpts = EmileImageLoadOpts;
pub type EvasImageAnimated = EmileImageAnimated;
pub type EvasImageProperty = EmileImageProperty;
pub type EvasLoadError = EmileImageLoadError;
pub type EvasImageAnimatedLoopHint = EmileImageAnimatedLoopHint;
pub type EvasImageScaleHint = EmileImageScaleHint;
pub type EvasColorspace = EmileColorspace;

#[repr(C)]
pub struct EvasImageLoadFunc {
    pub file_open: Option<unsafe extern "C" fn(f: *mut EinaFile,
                                               key: *mut EinaStringshare,
                                               opts: *mut EvasImageLoadOpts,
                                               animated: *mut EvasImageAnimated,
                                               error: *mut c_int)
                                             -> *mut c_void>,
    pub file_close: Option<unsafe extern "C" fn(loader_data: *mut c_void)>,
    pub file_head: Option<unsafe extern "C" fn(loader_data: *mut c_void,
                                               prop: *mut EvasImageProperty,
                                               error: *mut c_int)
                                             -> EinaBool>,
    pub file_data: Option<unsafe extern "C" fn(loader_data: *mut c_void,
                                               prop: *mut EvasImageProperty,
                                               pixels: *mut c_void,
                                               error: *mut c_int)
                                             -> EinaBool>,
    pub frame_duration: Option<unsafe extern "C" fn(loader_data: *mut c_void,
                                                    start: c_int,
                                                    frame_num: c_int)
                                                  -> c_double>,
    pub threadable: EinaBool,
    pub do_region: EinaBool,
}

pub type EvasModifierMask = c_ulonglong;
pub type EvasCoord = c_int;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasAspectControl {
    EvasAspectControlNone = 0,
    EvasAspectControlNeither = 1,
    EvasAspectControlHorizontal = 2,
    EvasAspectControlVertical = 3,
    EvasAspectControlBoth = 4,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasRenderOp {
    EvasRenderBlend = 0,
    EvasRenderBlendRel = 1,
    EvasRenderCopy = 2,
    EvasRenderCopyRel = 3,
    EvasRenderAdd = 4,
    EvasRenderAddRel = 5,
    EvasRenderSub = 6,
    EvasRenderSubRel = 7,
    EvasRenderTint = 8,
    EvasRenderTintRel = 9,
    EvasRenderMask = 10,
    EvasRenderMul = 11,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasObjectPointerMode {
    EvasObjectPointerModeAutograb = 0,
    EvasObjectPointerModeNograb = 1,
    EvasObjectPointerModeNograbNoRepeatUpdown = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasDisplayMode {
    EvasDisplayModeNone = 0,
    EvasDisplayModeCompress = 1,
    EvasDisplayModeExpand = 2,
    EvasDisplayModeDontChange = 3,
}

pub const EVAS_BIDI_DIRECTION_NEUTRAL: EvasBidiDirection =
    EvasBidiDirection::EvasBidiDirectionNatural;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasBidiDirection {
    EvasBidiDirectionNatural = 0,
    EvasBidiDirectionLtr = 1,
    EvasBidiDirectionRtl = 2,
}
pub const EVAS_TEXT_STYLE_SHADOW_DIRECTION_BOTTOM_RIGHT: EvasTextStyleType =
    EvasTextStyleType::EvasTextStylePlain;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTextStyleType {
    EvasTextStylePlain = 0,
    EvasTextStyleShadow = 1,
    EvasTextStyleOutline = 2,
    EvasTextStyleSoftOutline = 3,
    EvasTextStyleGlow = 4,
    EvasTextStyleOutlineShadow = 5,
    EvasTextStyleFarShadow = 6,
    EvasTextStyleOutlineSoftShadow = 7,
    EvasTextStyleSoftShadow = 8,
    EvasTextStyleFarSoftShadow = 9,
    EvasTextStyleShadowDirectionBottom = 16,
    EvasTextStyleShadowDirectionBottomLeft = 32,
    EvasTextStyleShadowDirectionLeft = 48,
    EvasTextStyleShadowDirectionTopLeft = 64,
    EvasTextStyleShadowDirectionTop = 80,
    EvasTextStyleShadowDirectionTopRight = 96,
    EvasTextStyleShadowDirectionRight = 112,
}

pub type EvasFontSize = c_int;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasFontHintingFlags {
    EvasFontHintingNone = 0,
    EvasFontHintingAuto = 1,
    EvasFontHintingBytecode = 2,
}
pub enum EvasMap { }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasButtonFlags {
    EvasButtonNone = 0,
    EvasButtonDoubleClick = 1,
    EvasButtonTripleClick = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasEventFlags {
    EvasEventFlagNone = 0,
    EvasEventFlagOnHold = 1,
    EvasEventFlagOnScroll = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTouchPointState {
    EVAS_TOUCH_POINT_DOWN = 0,
    EVAS_TOUCH_POINT_UP = 1,
    EVAS_TOUCH_POINT_MOVE = 2,
    EVAS_TOUCH_POINT_STILL = 3,
    EVAS_TOUCH_POINT_CANCEL = 4,
}
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCallbackType {
    EVAS_CALLBACK_MOUSE_IN = 0,
    EVAS_CALLBACK_MOUSE_OUT = 1,
    EVAS_CALLBACK_MOUSE_DOWN = 2,
    EVAS_CALLBACK_MOUSE_UP = 3,
    EVAS_CALLBACK_MOUSE_MOVE = 4,
    EVAS_CALLBACK_MOUSE_WHEEL = 5,
    EVAS_CALLBACK_MULTI_DOWN = 6,
    EVAS_CALLBACK_MULTI_UP = 7,
    EVAS_CALLBACK_MULTI_MOVE = 8,
    EVAS_CALLBACK_FREE = 9,
    EVAS_CALLBACK_KEY_DOWN = 10,
    EVAS_CALLBACK_KEY_UP = 11,
    EVAS_CALLBACK_FOCUS_IN = 12,
    EVAS_CALLBACK_FOCUS_OUT = 13,
    EVAS_CALLBACK_SHOW = 14,
    EVAS_CALLBACK_HIDE = 15,
    EVAS_CALLBACK_MOVE = 16,
    EVAS_CALLBACK_RESIZE = 17,
    EVAS_CALLBACK_RESTACK = 18,
    EVAS_CALLBACK_DEL = 19,
    EVAS_CALLBACK_HOLD = 20,
    EVAS_CALLBACK_CHANGED_SIZE_HINTS = 21,
    EVAS_CALLBACK_IMAGE_PRELOADED = 22,
    EVAS_CALLBACK_CANVAS_FOCUS_IN = 23,
    EVAS_CALLBACK_CANVAS_FOCUS_OUT = 24,
    EVAS_CALLBACK_RENDER_FLUSH_PRE = 25,
    EVAS_CALLBACK_RENDER_FLUSH_POST = 26,
    EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_IN = 27,
    EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_OUT = 28,
    EVAS_CALLBACK_IMAGE_UNLOADED = 29,
    EVAS_CALLBACK_RENDER_PRE = 30,
    EVAS_CALLBACK_RENDER_POST = 31,
    EVAS_CALLBACK_IMAGE_RESIZE = 32,
    EVAS_CALLBACK_DEVICE_CHANGED = 33,
    EVAS_CALLBACK_AXIS_UPDATE = 34,
    EVAS_CALLBACK_CANVAS_VIEWPORT_RESIZE = 35,
    EVAS_CALLBACK_LAST = 36,
}
pub enum EvasModifier { }
pub enum EvasLock { }
pub type EvasReal = c_double;

pub type EvasCanvas3DSurfaceFunc = 
    Option<unsafe extern "C" fn(out_x: *mut EvasReal, 
                                out_y: *mut EvasReal, 
                                out_z: *mut EvasReal, 
                                a: EvasReal, 
                                b: EvasReal)>;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DObjectType {
    EVAS_CANVAS3D_OBJECT_TYPE_INVALID = 0,
    EVAS_CANVAS3D_OBJECT_TYPE_SCENE = 1,
    EVAS_CANVAS3D_OBJECT_TYPE_NODE = 2,
    EVAS_CANVAS3D_OBJECT_TYPE_CAMERA = 3,
    EVAS_CANVAS3D_OBJECT_TYPE_LIGHT = 4,
    EVAS_CANVAS3D_OBJECT_TYPE_MODEL = 5,
    EVAS_CANVAS3D_OBJECT_TYPE_MESH = 6,
    EVAS_CANVAS3D_OBJECT_TYPE_TEXTURE = 7,
    EVAS_CANVAS3D_OBJECT_TYPE_MATERIAL = 8,
    EVAS_CANVAS3D_OBJECT_TYPE_PRIMITIVE = 9,
}
pub const EVAS_CANVAS3D_STATE_TEXTURE_DATA: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_TEXTURE_WRAP: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE;
pub const EVAS_CANVAS3D_STATE_TEXTURE_FILTER: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR;
pub const EVAS_CANVAS3D_STATE_MATERIAL_ID: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_MATERIAL_COLOR: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE;
pub const EVAS_CANVAS3D_STATE_MATERIAL_TEXTURE: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR;
pub const EVAS_CANVAS3D_STATE_MESH_VERTEX_COUNT: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_MESH_FRAME: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE;
pub const EVAS_CANVAS3D_STATE_MESH_MATERIAL: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR;
pub const EVAS_CANVAS3D_STATE_MESH_TRANSFORM: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SIZE;
pub const EVAS_CANVAS3D_STATE_MESH_VERTEX_DATA: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_ENABLED;
pub const EVAS_CANVAS3D_STATE_MESH_INDEX_DATA: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_UPDATED;
pub const EVAS_CANVAS3D_STATE_MESH_VERTEX_ASSEMBLY: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_DEPTH;
pub const EVAS_CANVAS3D_STATE_CAMERA_PROJECTION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_LIGHT_AMBIENT: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_LIGHT_DIFFUSE: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE;
pub const EVAS_CANVAS3D_STATE_LIGHT_SPECULAR: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR;
pub const EVAS_CANVAS3D_STATE_LIGHT_SPOT_DIR: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SIZE;
pub const EVAS_CANVAS3D_STATE_LIGHT_SPOT_EXP: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_ENABLED;
pub const EVAS_CANVAS3D_STATE_LIGHT_SPOT_CUTOFF: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_UPDATED;
pub const EVAS_CANVAS3D_STATE_LIGHT_ATTENUATION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_DEPTH;
pub const EVAS_CANVAS3D_STATE_LIGHT_PROJECTION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_SHADE_MODE;
pub const EVAS_CANVAS3D_STATE_NODE_TRANSFORM_POSITION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE;
pub const EVAS_CANVAS3D_STATE_NODE_TRANSFORM_ORIENTATION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE;
pub const EVAS_CANVAS3D_STATE_NODE_TRANSFORM_SCALE: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR;
pub const EVAS_CANVAS3D_STATE_NODE_MESH_GEOMETRY: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SIZE;
pub const EVAS_CANVAS3D_STATE_NODE_MESH_MATERIAL: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_ENABLED;
pub const EVAS_CANVAS3D_STATE_NODE_MESH_FRAME: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_UPDATED;
pub const EVAS_CANVAS3D_STATE_NODE_MESH_SHADE_MODE: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_SCENE_SHADOWS_DEPTH;
pub const EVAS_CANVAS3D_STATE_NODE_MESH_MATERIAL_ID: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_SHADE_MODE;
pub const EVAS_CANVAS3D_STATE_NODE_LIGHT: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_FOG;
pub const EVAS_CANVAS3D_STATE_NODE_CAMERA: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_BLENDING;
pub const EVAS_CANVAS3D_STATE_NODE_PARENT_POSITION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_ALPHA_TEST;
pub const EVAS_CANVAS3D_STATE_NODE_PARENT_ORIENTATION: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_COLOR_PICK;
pub const EVAS_CANVAS3D_STATE_NODE_PARENT_SCALE: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_SHADOWS_EDGES_FILTERING;
pub const EVAS_CANVAS3D_STATE_NODE_MEMBER: EvasCanvas3DState =
    EvasCanvas3DState::EVAS_CANVAS3D_STATE_MESH_SHADOWS_CONSTANT_BIAS;
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DState {
    EVAS_CANVAS3D_STATE_MAX = 16,
    EVAS_CANVAS3D_STATE_ANY = 0,
    EVAS_CANVAS3D_STATE_SCENE_ROOT_NODE = 1,
    EVAS_CANVAS3D_STATE_SCENE_CAMERA_NODE = 2,
    EVAS_CANVAS3D_STATE_SCENE_BACKGROUND_COLOR = 3,
    EVAS_CANVAS3D_STATE_SCENE_SIZE = 4,
    EVAS_CANVAS3D_STATE_SCENE_SHADOWS_ENABLED = 5,
    EVAS_CANVAS3D_STATE_SCENE_UPDATED = 6,
    EVAS_CANVAS3D_STATE_SCENE_SHADOWS_DEPTH = 7,
    EVAS_CANVAS3D_STATE_MESH_SHADE_MODE = 8,
    EVAS_CANVAS3D_STATE_MESH_FOG = 9,
    EVAS_CANVAS3D_STATE_MESH_BLENDING = 10,
    EVAS_CANVAS3D_STATE_MESH_ALPHA_TEST = 11,
    EVAS_CANVAS3D_STATE_MESH_COLOR_PICK = 12,
    EVAS_CANVAS3D_STATE_MESH_SHADOWS_EDGES_FILTERING = 13,
    EVAS_CANVAS3D_STATE_MESH_SHADOWS_CONSTANT_BIAS = 14,
    EVAS_CANVAS3D_STATE_NODE_PARENT_BILLBOARD = 15,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DSpace {
    EVAS_CANVAS3D_SPACE_LOCAL = 0,
    EVAS_CANVAS3D_SPACE_PARENT = 1,
    EVAS_CANVAS3D_SPACE_WORLD = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DNodeType {
    EVAS_CANVAS3D_NODE_TYPE_NODE = 0,
    EVAS_CANVAS3D_NODE_TYPE_CAMERA = 1,
    EVAS_CANVAS3D_NODE_TYPE_LIGHT = 2,
    EVAS_CANVAS3D_NODE_TYPE_MESH = 3,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DNodeOrientationType {
    EVAS_CANVAS3D_NODE_ORIENTATION_TYPE_NONE = 0,
    EVAS_CANVAS3D_NODE_ORIENTATION_TYPE_LOOK_AT = 1,
    EVAS_CANVAS3D_NODE_ORIENTATION_TYPE_LOOK_TO = 2,
    EVAS_CANVAS3D_NODE_ORIENTATION_TYPE_ANGLE_AXIS = 3,
    EVAS_CANVAS3D_NODE_ORIENTATION_TYPE_QUATERNION = 4,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DIndexFormat {
    EVAS_CANVAS3D_INDEX_FORMAT_NONE = 0,
    EVAS_CANVAS3D_INDEX_FORMAT_UNSIGNED_BYTE = 1,
    EVAS_CANVAS3D_INDEX_FORMAT_UNSIGNED_SHORT = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DFrustumMode {
    EVAS_CANVAS3D_FRUSTUM_MODE_BSPHERE = 0,
    EVAS_CANVAS3D_FRUSTUM_MODE_AABB = 1,
    EVAS_CANVAS3D_FRUSTUM_MODE_CENTRAL_POINT = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DVertexAssembly {
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_POINTS = 0,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_LINES = 1,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_LINE_STRIP = 2,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_LINE_LOOP = 3,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_TRIANGLES = 4,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_TRIANGLE_STRIP = 5,
    EVAS_CANVAS3D_VERTEX_ASSEMBLY_TRIANGLE_FAN = 6,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DComparison {
    EVAS_CANVAS3D_COMPARISON_NEVER = 0,
    EVAS_CANVAS3D_COMPARISON_LESS = 1,
    EVAS_CANVAS3D_COMPARISON_EQUAL = 2,
    EVAS_CANVAS3D_COMPARISON_LEQUAL = 3,
    EVAS_CANVAS3D_COMPARISON_GREATER = 4,
    EVAS_CANVAS3D_COMPARISON_NOTEQUAL = 5,
    EVAS_CANVAS3D_COMPARISON_GEQUAL = 6,
    EVAS_CANVAS3D_COMPARISON_ALWAYS = 7,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DWrapMode {
    EVAS_CANVAS3D_WRAP_MODE_CLAMP = 0,
    EVAS_CANVAS3D_WRAP_MODE_REPEAT = 1,
    EVAS_CANVAS3D_WRAP_MODE_REFLECT = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DTextureFilter {
    EVAS_CANVAS3D_TEXTURE_FILTER_NEAREST = 0,
    EVAS_CANVAS3D_TEXTURE_FILTER_LINEAR = 1,
    EVAS_CANVAS3D_TEXTURE_FILTER_NEAREST_MIPMAP_NEAREST = 2,
    EVAS_CANVAS3D_TEXTURE_FILTER_LINEAR_MIPMAP_NEAREST = 3,
    EVAS_CANVAS3D_TEXTURE_FILTER_NEAREST_MIPMAP_LINEAR = 4,
    EVAS_CANVAS3D_TEXTURE_FILTER_LINEAR_MIPMAP_LINEAR = 5,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DMeshPrimitive {
    EVAS_CANVAS3D_MESH_PRIMITIVE_NONE = 0,
    EVAS_CANVAS3D_MESH_PRIMITIVE_SQUARE = 1,
    EVAS_CANVAS3D_MESH_PRIMITIVE_CUBE = 2,
    EVAS_CANVAS3D_MESH_PRIMITIVE_CYLINDER = 3,
    EVAS_CANVAS3D_MESH_PRIMITIVE_CONE = 4,
    EVAS_CANVAS3D_MESH_PRIMITIVE_SPHERE = 5,
    EVAS_CANVAS3D_MESH_PRIMITIVE_TORUS = 6,
    EVAS_CANVAS3D_MESH_PRIMITIVE_SURFACE = 7,
    EVAS_CANVAS3D_MESH_PRIMITIVE_TERRAIN = 8,
    EVAS_CANVAS3D_MESH_PRIMITIVE_COUNT = 9,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DPrimitiveMode {
    EVAS_CANVAS3D_PRIMITIVE_MODE_DEFAULT = 0,
    EVAS_CANVAS3D_PRIMITIVE_MODE_WITHOUT_BASE = 1,
    EVAS_CANVAS3D_PRIMITIVE_MODE_ALTERNATIVE_UV = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DShadeMode {
    EVAS_CANVAS3D_SHADE_MODE_VERTEX_COLOR = 0,
    EVAS_CANVAS3D_SHADE_MODE_DIFFUSE = 1,
    EVAS_CANVAS3D_SHADE_MODE_FLAT = 2,
    EVAS_CANVAS3D_SHADE_MODE_PHONG = 3,
    EVAS_CANVAS3D_SHADE_MODE_NORMAL_MAP = 4,
    EVAS_CANVAS3D_SHADE_MODE_SHADOW_MAP_RENDER = 5,
    EVAS_CANVAS3D_SHADE_MODE_COLOR_PICK = 6,
    EVAS_CANVAS3D_SHADE_MODE_PARALLAX_OCCLUSION = 7,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DVertexAttrib {
    EVAS_CANVAS3D_VERTEX_ATTRIB_POSITION = 0,
    EVAS_CANVAS3D_VERTEX_ATTRIB_NORMAL = 1,
    EVAS_CANVAS3D_VERTEX_ATTRIB_TANGENT = 2,
    EVAS_CANVAS3D_VERTEX_ATTRIB_COLOR = 3,
    EVAS_CANVAS3D_VERTEX_ATTRIB_TEXCOORD = 4,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DBlendFunc {
    EVAS_CANVAS3D_BLEND_FUNC_ZERO = 0,
    EVAS_CANVAS3D_BLEND_FUNC_ONE = 1,
    EVAS_CANVAS3D_BLEND_FUNC_SRC_COLOR = 2,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_SRC_COLOR = 3,
    EVAS_CANVAS3D_BLEND_FUNC_DST_COLOR = 4,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_DST_COLOR = 5,
    EVAS_CANVAS3D_BLEND_FUNC_SRC_ALPHA = 6,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_SRC_ALPHA = 7,
    EVAS_CANVAS3D_BLEND_FUNC_DST_ALPHA = 8,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_DST_ALPHA = 9,
    EVAS_CANVAS3D_BLEND_FUNC_CONSTANT_COLOR = 10,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_CONSTANT_COLOR = 11,
    EVAS_CANVAS3D_BLEND_FUNC_CONSTANT_ALPHA = 12,
    EVAS_CANVAS3D_BLEND_FUNC_ONE_MINUS_CONSTANT_ALPHA = 13,
    EVAS_CANVAS3D_BLEND_FUNC_SRC_ALPHA_SATURATE = 14,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasCanvas3DMaterialAttrib {
    EVAS_CANVAS3D_MATERIAL_ATTRIB_AMBIENT = 0,
    EVAS_CANVAS3D_MATERIAL_ATTRIB_DIFFUSE = 1,
    EVAS_CANVAS3D_MATERIAL_ATTRIB_SPECULAR = 2,
    EVAS_CANVAS3D_MATERIAL_ATTRIB_EMISSION = 3,
    EVAS_CANVAS3D_MATERIAL_ATTRIB_NORMAL = 4,
}

#[repr(C)]
pub struct EvasVersion {
    pub major: c_int,
    pub minor: c_int,
    pub micro: c_int,
    pub revision: c_int,
}

pub type EvasCallbackPriority = EoCallbackPriority;
pub type Evas = Eo;
pub enum EvasPublicData { }
pub type EvasObject = Eo;
pub type EflVg = Eo;
pub type EvasPerformance = c_void;
pub enum EvasSmart { }
pub type EvasAngle = c_int;

#[repr(C)]
pub struct EvasCoordRectangle {
    pub x: EvasCoord,
    pub y: EvasCoord,
    pub w: EvasCoord,
    pub h: EvasCoord,
}

#[repr(C)]
pub struct EvasCoordPoint {
    pub x: EvasCoord,
    pub y: EvasCoord,
}

#[repr(C)]
pub struct EvasCoordSize {
    pub w: EvasCoord,
    pub h: EvasCoord,
}

#[repr(C)]
pub struct EvasCoordPrecisionSize {
    pub w: EvasCoord,
    pub h: EvasCoord,
    pub wsub: c_double,
    pub ysub: c_double,
}

#[repr(C)]
pub struct EvasCoordPrecisionPoint {
    pub x: EvasCoord,
    pub y: EvasCoord,
    pub xsub: c_double,
    pub ysub: c_double,
}

#[repr(C)]
pub struct EvasPoint {
    pub x: c_int,
    pub y: c_int,
}

#[repr(C)]
pub struct EvasPosition {
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
}

#[repr(C)]
pub struct EvasPrecisionPosition {
    pub output: EvasPoint,
    pub canvas: EvasCoordPrecisionPoint,
}

pub enum EvasDevice { }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasAllocError {
    EVAS_ALLOC_ERROR_NONE = 0,
    EVAS_ALLOC_ERROR_FATAL = 1,
    EVAS_ALLOC_ERROR_RECOVERED = 2,
}

pub type EvasFillSpread = EflGfxFillSpread;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasPixelImportPixelFormat {
    EVAS_PIXEL_FORMAT_NONE = 0,
    EVAS_PIXEL_FORMAT_ARGB32 = 1,
    EVAS_PIXEL_FORMAT_YUV420P_601 = 2,
}

#[repr(C)]
pub struct EvasPixelImportSource {
    pub format: EvasPixelImportPixelFormat,
    pub w: c_int,
    pub h: c_int,
    pub rows: *mut *mut c_void,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasNativeSurfaceType {
    EVAS_NATIVE_SURFACE_NONE = 0,
    EVAS_NATIVE_SURFACE_X11 = 1,
    EVAS_NATIVE_SURFACE_OPENGL = 2,
    EVAS_NATIVE_SURFACE_WL = 3,
    EVAS_NATIVE_SURFACE_TBM = 4,
    EVAS_NATIVE_SURFACE_EVASGL = 5,
}

#[repr(C)]
pub struct EvasNativeSurface {
    pub version: c_int,
    pub _type: EvasNativeSurfaceType,
    pub data: EvasUnionUnnamed30,
}

#[repr(C)]
#[derive(Copy)]
pub struct EvasUnionUnnamed30 {
    pub _bindgen_data_: [u64; 4usize],
}
impl EvasUnionUnnamed30 {
    pub unsafe fn x11(&mut self) -> *mut EvasStructUnnamed31 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn opengl(&mut self) -> *mut EvasStructUnnamed32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn wl(&mut self) -> *mut EvasStructUnnamed33 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tbm(&mut self) -> *mut EvasStructUnnamed34 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn evasgl(&mut self) -> *mut EvasStructUnnamed35 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for EvasUnionUnnamed30 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasUnionUnnamed30 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EvasStructUnnamed31 {
    pub visual: *mut c_void,
    pub pixmap: c_ulong,
}
impl ::std::clone::Clone for EvasStructUnnamed31 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasStructUnnamed31 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EvasStructUnnamed32 {
    pub texture_id: c_uint,
    pub framebuffer_id: c_uint,
    pub internal_format: c_uint,
    pub format: c_uint,
    pub x: c_uint,
    pub y: c_uint,
    pub w: c_uint,
    pub h: c_uint,
}
impl ::std::clone::Clone for EvasStructUnnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasStructUnnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EvasStructUnnamed33 {
    pub legacy_buffer: *mut c_void,
}
impl ::std::clone::Clone for EvasStructUnnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasStructUnnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EvasStructUnnamed34 {
    pub buffer: *mut c_void,
}
impl ::std::clone::Clone for EvasStructUnnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasStructUnnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EvasStructUnnamed35 {
    pub surface: *mut c_void,
}
impl ::std::clone::Clone for EvasStructUnnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EvasStructUnnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type EvasVideoCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                   obj: *mut EvasObject,
                                                   surface:
                                                   *const EvasVideoSurface)>;
pub type EvasVideoCoordCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                               obj: *mut EvasObject,
                                               surface: *const EvasVideoSurface,
                                               a: EvasCoord, b: EvasCoord)>;
#[repr(C)]
pub struct EvasVideoSurface {
    pub version: c_int,
    pub _move: EvasVideoCoordCb,
    pub resize: EvasVideoCoordCb,
    pub show: EvasVideoCb,
    pub hide: EvasVideoCb,
    pub update_pixels: EvasVideoCb,
    pub parent: *mut EvasObject,
    pub data: *mut c_void,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasVideoSurfaceCaps {
    EVAS_VIDEO_SURFACE_MOVE = 1,
    EVAS_VIDEO_SURFACE_RESIZE = 2,
    EVAS_VIDEO_SURFACE_CLIP = 4,
    EVAS_VIDEO_SURFACE_BELOW = 8,
    EVAS_VIDEO_SURFACE_STACKING_CHECK = 16,
    EVAS_VIDEO_SURFACE_IGNORE_WINDOW = 32,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasBorderFillMode {
    EVAS_BORDER_FILL_NONE = 0,
    EVAS_BORDER_FILL_DEFAULT = 1,
    EVAS_BORDER_FILL_SOLID = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasEngineRenderMode {
    EVAS_RENDER_MODE_BLOCKING = 0,
    EVAS_RENDER_MODE_NONBLOCKING = 1,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasImageContentHint {
    EVAS_IMAGE_CONTENT_HINT_NONE = 0,
    EVAS_IMAGE_CONTENT_HINT_DYNAMIC = 1,
    EVAS_IMAGE_CONTENT_HINT_STATIC = 2,
}

pub const EVAS_IMAGE_ORIENT_0: EvasImageOrient =
    EvasImageOrient::EVAS_IMAGE_ORIENT_NONE;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasImageOrient {
    EVAS_IMAGE_ORIENT_NONE = 0,
    EVAS_IMAGE_ORIENT_90 = 1,
    EVAS_IMAGE_ORIENT_180 = 2,
    EVAS_IMAGE_ORIENT_270 = 3,
    EVAS_IMAGE_FLIP_HORIZONTAL = 4,
    EVAS_IMAGE_FLIP_VERTICAL = 5,
    EVAS_IMAGE_FLIP_TRANSPOSE = 6,
    EVAS_IMAGE_FLIP_TRANSVERSE = 7,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasDeviceClass {
    EVAS_DEVICE_CLASS_NONE = 0,
    EVAS_DEVICE_CLASS_SEAT = 1,
    EVAS_DEVICE_CLASS_KEYBOARD = 2,
    EVAS_DEVICE_CLASS_MOUSE = 3,
    EVAS_DEVICE_CLASS_TOUCH = 4,
    EVAS_DEVICE_CLASS_PEN = 5,
    EVAS_DEVICE_CLASS_POINTER = 6,
    EVAS_DEVICE_CLASS_GAMEPAD = 7,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasDeviceSubclass {
    EVAS_DEVICE_SUBCLASS_NONE = 0,
    EVAS_DEVICE_SUBCLASS_FINGER = 1,
    EVAS_DEVICE_SUBCLASS_FINGERNAIL = 2,
    EVAS_DEVICE_SUBCLASS_KNUCKLE = 3,
    EVAS_DEVICE_SUBCLASS_PALM = 4,
    EVAS_DEVICE_SUBCLASS_HAND_SIZE = 5,
    EVAS_DEVICE_SUBCLASS_HAND_FLAT = 6,
    EVAS_DEVICE_SUBCLASS_PEN_TIP = 7,
    EVAS_DEVICE_SUBCLASS_TRACKPAD = 8,
    EVAS_DEVICE_SUBCLASS_TRACKPOINT = 9,
    EVAS_DEVICE_SUBCLASS_TRACKBALL = 10,
}

#[repr(C)]
pub struct EvasEngineInfo {
    pub magic: c_int,
}

#[repr(C)]
pub struct EvasEventMouseDown {
    pub button: c_int,
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub flags: EvasButtonFlags,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub event_src: *mut EvasObject,
}

#[repr(C)]
pub struct EvasEventMouseUp {
    pub button: c_int,
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub flags: EvasButtonFlags,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub event_src: *mut EvasObject,
}

#[repr(C)]
pub struct EvasEventMouseIn {
    pub buttons: c_int,
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub event_src: *mut EvasObject,
}

#[repr(C)]
pub struct EvasEventMouseOut {
    pub buttons: c_int,
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub event_src: *mut EvasObject,
}

#[repr(C)]
pub struct EvasEventMouseMove {
    pub buttons: c_int,
    pub cur: EvasPosition,
    pub prev: EvasPosition,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub event_src: *mut EvasObject,
}

#[repr(C)]
pub struct EvasEventMouseWheel {
    pub direction: c_int,
    pub z: c_int,
    pub output: EvasPoint,
    pub canvas: EvasCoordPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
}

#[repr(C)]
pub struct EvasEventMultiDown {
    pub device: c_int,
    pub radius: c_double,
    pub radius_x: c_double,
    pub radius_y: c_double,
    pub pressure: c_double,
    pub angle: c_double,
    pub output: EvasPoint,
    pub canvas: EvasCoordPrecisionPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub flags: EvasButtonFlags,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
}

#[repr(C)]
pub struct EvasEventMultiUp {
    pub device: c_int,
    pub radius: c_double,
    pub radius_x: c_double,
    pub radius_y: c_double,
    pub pressure: c_double,
    pub angle: c_double,
    pub output: EvasPoint,
    pub canvas: EvasCoordPrecisionPoint,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub flags: EvasButtonFlags,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
}

#[repr(C)]
pub struct EvasEventMultiMove {
    pub device: c_int,
    pub radius: c_double,
    pub radius_x: c_double,
    pub radius_y: c_double,
    pub pressure: c_double,
    pub angle: c_double,
    pub cur: EvasPrecisionPosition,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
}

#[repr(C)]
pub struct EvasEventKeyDown {
    pub keyname: *mut c_char,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub key: *const c_char,
    pub string: *const c_char,
    pub compose: *const c_char,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub keycode: c_uint,
}

#[repr(C)]
pub struct EvasEventKeyUp {
    pub keyname: *mut c_char,
    pub data: *mut c_void,
    pub modifiers: *mut EvasModifier,
    pub locks: *mut EvasLock,
    pub key: *const c_char,
    pub string: *const c_char,
    pub compose: *const c_char,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
    pub keycode: c_uint,
}

#[repr(C)]
pub struct EvasEventRenderPost {
    pub updated_area: *mut EinaList,
}

#[repr(C)]
pub struct EvasEventHold {
    pub hold: c_int,
    pub data: *mut c_void,
    pub timestamp: c_uint,
    pub event_flags: EvasEventFlags,
    pub dev: *mut EvasDevice,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasAxisLabel {
    EVAS_AXIS_LABEL_UNKNOWN = 0,
    EVAS_AXIS_LABEL_X = 1,
    EVAS_AXIS_LABEL_Y = 2,
    EVAS_AXIS_LABEL_PRESSURE = 3,
    EVAS_AXIS_LABEL_DISTANCE = 4,
    EVAS_AXIS_LABEL_AZIMUTH = 5,
    EVAS_AXIS_LABEL_TILT = 6,
    EVAS_AXIS_LABEL_TWIST = 7,
    EVAS_AXIS_LABEL_TOUCH_WIDTH_MAJOR = 8,
    EVAS_AXIS_LABEL_TOUCH_WIDTH_MINOR = 9,
    EVAS_AXIS_LABEL_TOOL_WIDTH_MAJOR = 10,
    EVAS_AXIS_LABEL_TOOL_WIDTH_MINOR = 11,
}

#[repr(C)]
pub struct EvasAxis {
    pub label: EvasAxisLabel,
    pub value: c_double,
}

#[repr(C)]
pub struct EvasEventAxisUpdate {
    pub data: *mut c_void,
    pub timestamp: c_uint,
    pub device: c_int,
    pub toolid: c_int,
    pub naxis: c_int,
    pub axis: *mut EvasAxis,
    pub dev: *mut EvasDevice,
}

pub type EvasSmartCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                   obj: *mut EvasObject,
                                                   event_info: *mut c_void)>;
pub type EvasEventCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                   e: *mut Evas,
                                                   event_info: *mut c_void)>;
pub type EvasObjectEventPostCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                             e: *mut Evas) 
                                                             -> EinaBool>;
pub type EvasObjectEventCb = Option<unsafe extern "C" fn(data: *mut c_void,
                                                         e: *mut Evas,
                                                         obj: *mut EvasObject,
                                                         event_info:
                                                         *mut c_void)>;
pub type EvasAsyncEventsPutCb =
    Option<unsafe extern "C" fn(target: *mut c_void,
                                _type: EvasCallbackType,
                                event_info: *mut c_void)>;
pub type EvasObjectInterceptShowCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject)>;
pub type EvasObjectInterceptHideCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject)>;
pub type EvasObjectInterceptMoveCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                x: EvasCoord, y: EvasCoord)>;
pub type EvasObjectInterceptResizeCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                w: EvasCoord, h: EvasCoord)>;
pub type EvasObjectInterceptRaiseCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject)>;
pub type EvasObjectInterceptLowerCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject)>;
pub type EvasObjectInterceptStackAboveCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                above: *mut EvasObject)>;
pub type EvasObjectInterceptStackBelowCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                above: *mut EvasObject)>;
pub type EvasObjectInterceptLayerSetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                l: c_int)>;
pub type EvasObjectInterceptFocusSetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                focus: EinaBool)>;
pub type EvasObjectInterceptColorSetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                r: c_int,
                                g: c_int,
                                b: c_int,
                                a: c_int)>;
pub type EvasObjectInterceptClipSetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject,
                                clip: *mut EvasObject)>;
pub type EvasObjectInterceptClipUnsetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                obj: *mut EvasObject)>;
pub type EvasObjectImagePixelsGetCb =
    Option<unsafe extern "C" fn(data: *mut c_void,
                                o: *mut EvasObject)>;
pub enum EvasTextblockStyle { }
pub enum EvasTextblockCursor { }
pub enum EvasTextblockNodeFormat { }
pub type EvasObjectTextblockNodeFormat = EvasTextblockNodeFormat;

#[repr(C)]
pub struct EvasTextblockRectangle {
    pub x: EvasCoord,
    pub y: EvasCoord,
    pub w: EvasCoord,
    pub h: EvasCoord,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTextblockTextType {
    EVAS_TEXTBLOCK_TEXT_RAW = 0,
    EVAS_TEXTBLOCK_TEXT_PLAIN = 1,
    EVAS_TEXTBLOCK_TEXT_MARKUP = 2,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTextblockCursorType {
    EVAS_TEXTBLOCK_CURSOR_UNDER = 0,
    EVAS_TEXTBLOCK_CURSOR_BEFORE = 1,
}

#[repr(C)]
pub struct EvasTextgridCell {
    pub codepoint: EinaUnicode,
    pub fg: c_uchar,
    pub bg: c_uchar,
    pub _bindgen_bitfield_1_: c_ushort,
}

#[repr(C)]
pub struct EvasSmartClass {
    pub name: *const c_char,
    pub version: c_int,
    pub add: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub del: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub _move: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                           x: EvasCoord,
                                           y: EvasCoord)>,
    pub resize: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                            w: EvasCoord,
                                            h: EvasCoord)>,
    pub show: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub hide: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub color_set: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                               r: c_int,
                                               g: c_int,
                                               b: c_int,
                                               a: c_int)>,
    pub clip_set: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                              clip: *mut EvasObject)>,
    pub clip_unset: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub calculate: Option<unsafe extern "C" fn(o: *mut EvasObject)>,
    pub member_add: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                child: *mut EvasObject)>,
    pub member_del: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                child: *mut EvasObject)>,
    pub parent: *const EvasSmartClass,
    pub callbacks: *const EvasSmartCbDescription,
    pub interfaces: *mut *const EvasSmartInterface,
    pub data: *const c_void,
}

#[repr(C)]
pub struct EvasSmartInterface {
    pub name: *const c_char,
    pub private_size: c_uint,
    pub add: Option<unsafe extern "C" fn(obj: *mut EvasObject) -> EinaBool>,
    pub del: Option<unsafe extern "C" fn(obj: *mut EvasObject)>,
}

#[repr(C)]
pub struct EvasSmartCbDescription {
    pub name: *const c_char,
    pub _type: *const c_char,
}

#[repr(C)]
pub struct EvasObjectSmartClippedData {
    pub clipper: *mut EvasObject,
    pub evas: *mut Evas,
}

pub type EvasObjectBoxLayout =
    Option<unsafe extern "C" fn(o: *mut EvasObject,
                                _priv: *mut EvasObjectBoxData,
                                user_data: *mut c_void)>;
pub enum EvasObjectBoxApi {}
/* va_list not supported yet
#[repr(C)]
pub struct EvasObjectBoxApi {
    pub base: EvasSmartClass,
    pub version: c_int,
    pub append: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                            _priv: *mut EvasObjectBoxData,
                                            child: *mut EvasObject)
                                            -> *mut EvasObjectBoxOption>,
    pub prepend: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                             _priv: *mut EvasObjectBoxData,
                                             child: *mut EvasObject)
                                           -> *mut EvasObjectBoxOption>,
    pub insert_before: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                  _priv: *mut EvasObjectBoxData,
                                                   child: *mut EvasObject,
                                                   reference: *const EvasObject)
                                                 -> *mut EvasObjectBoxOption>,
    pub insert_after: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                  _priv: *mut EvasObjectBoxData,
                                                  child: *mut EvasObject,
                                                  reference: *const EvasObject)
                                                  -> *mut EvasObjectBoxOption>,
    pub insert_at: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                               _priv: *mut EvasObjectBoxData,
                                               child: *mut EvasObject,
                                               pos: c_uint)
                                             -> *mut EvasObjectBoxOption>,
    pub remove: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                            _priv: *mut EvasObjectBoxData,
                                            child: *mut EvasObject)
                                          -> *mut EvasObject>,
    pub remove_at: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                               _priv: *mut EvasObjectBoxData,
                                               pos: c_uint)
                                             -> *mut EvasObject>,
    pub property_set: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                  opt: *mut EvasObjectBoxOption,
                                                  property: c_int,
                                                  args: va_list)
                                                -> EinaBool>,
    pub property_get: Option<unsafe extern "C" fn(o: *const EvasObject,
                                                  opt: *mut EvasObjectBoxOption,
                                                  property: c_int,
                                                  args: va_list)
                                                -> EinaBool>,
    pub property_name_get: Option<unsafe extern "C" fn(o: *const EvasObject,
                                                       property: c_int)
                                                     -> *const c_char>,
    pub property_id_get: Option<unsafe extern "C" fn(o: *const EvasObject,
                                                     name: *const c_char)
                                                   -> c_int>,
    pub option_new: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                _priv: *mut EvasObjectBoxData,
                                                child: *mut EvasObject)
                                              -> *mut EvasObjectBoxOption>,
    pub option_free: Option<unsafe extern "C" fn(o: *mut EvasObject,
                                                 _priv: *mut EvasObjectBoxData,
                                                 opt: *mut EvasObjectBoxOption)>,
}
*/

#[repr(C)]
pub struct EvasObjectBoxData {
    pub base: EvasObjectSmartClippedData,
    pub api: *const EvasObjectBoxApi,
    pub align: EvasStructUnnamed36,
    pub pad: EvasStructUnnamed37,
    pub children: *mut EinaList,
    pub layout: EvasStructUnnamed38,
    pub _bindgen_bitfield_1_: EinaBool,
    pub _bindgen_bitfield_2_: EinaBool,
}

#[repr(C)]
pub struct EvasStructUnnamed36 {
    pub h: c_double,
    pub v: c_double,
}

#[repr(C)]
pub struct EvasStructUnnamed37 {
    pub h: EvasCoord,
    pub v: EvasCoord,
}

#[repr(C)]
pub struct EvasStructUnnamed38 {
    pub cb: EvasObjectBoxLayout,
    pub data: *mut c_void,
    pub free_data: Option<unsafe extern "C" fn(data:
                                                                  *mut c_void)>,
}

#[repr(C)]
pub struct EvasObjectBoxOption {
    pub obj: *mut EvasObject,
    pub _bindgen_bitfield_1_: EinaBool,
    pub _bindgen_bitfield_2_: EinaBool,
    pub alloc_size: EvasCoord,
}

#[repr(C)]
pub struct EvasCserveStats {
    pub saved_memory: c_int,
    pub wasted_memory: c_int,
    pub saved_memory_peak: c_int,
    pub wasted_memory_peak: c_int,
    pub saved_time_image_header_load: c_double,
    pub saved_time_image_data_load: c_double,
}

#[repr(C)]
pub struct EvasCserveImageCache {
    pub active: EvasStructUnnamed39,
    pub cached: EvasStructUnnamed39,
    pub images: *mut EinaList,
}

#[repr(C)]
pub struct EvasStructUnnamed39 {
    pub mem_total: c_int,
    pub count: c_int,
}

#[repr(C)]
pub struct EvasCserveImage {
    pub file: *const c_char,
    pub key: *const c_char,
    pub w: c_int,
    pub h: c_int,
    pub file_mod_time: time_t,
    pub file_checked_time: time_t,
    pub cached_time: time_t,
    pub refcount: c_int,
    pub data_refcount: c_int,
    pub memory_footprint: c_int,
    pub head_load_time: c_double,
    pub data_load_time: c_double,
    pub _bindgen_bitfield_1_: EinaBool,
    pub _bindgen_bitfield_2_: EinaBool,
    pub _bindgen_bitfield_3_: EinaBool,
    pub _bindgen_bitfield_4_: EinaBool,
    pub _bindgen_bitfield_5_: EinaBool,
}

#[repr(C)]
pub struct EvasCserveConfig {
    pub cache_max_usage: c_int,
    pub cache_item_timeout: c_int,
    pub cache_item_timeout_check: c_int,
}

pub type EvasOut = Eo;
pub type EvasCanvas = Eo;
pub type EvasCommonInterface = Eo;
pub type EvasRectangle = Eo;
pub type EvasImage = Eo;
pub type EvasText = Eo;
pub type EvasTextblock = Eo;
pub type EvasTextgrid = Eo;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTextgridPalette {
    EVAS_TEXTGRID_PALETTE_NONE = 0,
    EVAS_TEXTGRID_PALETTE_STANDARD = 1,
    EVAS_TEXTGRID_PALETTE_EXTENDED = 2,
    EVAS_TEXTGRID_PALETTE_LAST = 3,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasTextgridFontStyle {
    EVAS_TEXTGRID_FONT_STYLE_NORMAL = 1,
    EVAS_TEXTGRID_FONT_STYLE_BOLD = 2,
    EVAS_TEXTGRID_FONT_STYLE_ITALIC = 4,
}
pub type EvasLine = Eo;
pub type EvasPolygon = Eo;
pub type EvasObjectSmart = Eo;
pub type EvasSmartClipped = Eo;
pub type EvasBox = Eo;
pub type EvasTable = Eo;

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EvasObjectTableHomogeneousMode {
    EVAS_OBJECT_TABLE_HOMOGENEOUS_NONE = 0,
    EVAS_OBJECT_TABLE_HOMOGENEOUS_TABLE = 1,
    EVAS_OBJECT_TABLE_HOMOGENEOUS_ITEM = 2,
}
pub type EvasGrid = Eo;
pub type EvasSignalInterface = Eo;
pub type EvasDraggableInterface = Eo;
pub type EvasClickableInterface = Eo;
pub type EvasScrollableInterface = Eo;
pub type EvasSelectableInterface = Eo;
pub type EvasZoomableInterface = Eo;
pub type EvasCanvas3DObject = Eo;
pub type EvasCanvas3DTexture = Eo;
pub type EvasCanvas3DMaterial = Eo;
pub type EvasCanvas3DLight = Eo;
pub type EvasCanvas3DPrimitive = Eo;
pub type EvasCanvas3DMesh = Eo;
pub type EvasCanvas3DNode = Eo;
pub type EvasCanvas3DCamera = Eo;
pub type EvasCanvas3DScene = Eo;
pub type EvasVg = Eo;
pub type EflVgBase = Eo;
pub type EflVgContainer = Eo;
pub type EflVgShape = Eo;
pub type EflVgGradient = Eo;
pub type EflVgGradientLinear = Eo;
pub type EflVgGradientRadial = Eo;

#[link(name = "evas")]
extern "C" {
    pub static mut evas_version: *mut EvasVersion;
    pub static _EVAS_CANVAS_EVENT_FOCUS_IN: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_FOCUS_OUT: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_RENDER_FLUSH_PRE: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_RENDER_FLUSH_POST: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_OBJECT_FOCUS_IN: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_OBJECT_FOCUS_OUT: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_RENDER_PRE: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_RENDER_POST: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_DEVICE_CHANGED: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_AXIS_UPDATE: EoEventDescription;
    pub static _EVAS_CANVAS_EVENT_VIEWPORT_RESIZE: EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG: EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START:
               EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_STOP:
               EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_END: EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_UP:
               EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_DOWN:
               EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_RIGHT:
               EoEventDescription;
    pub static _EVAS_DRAGGABLE_INTERFACE_EVENT_DRAG_START_LEFT:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED: EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_DOUBLE:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_TRIPLE:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_CLICKED_RIGHT:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_PRESSED: EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_UNPRESSED:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_LONGPRESSED:
               EoEventDescription;
    pub static _EVAS_CLICKABLE_INTERFACE_EVENT_REPEATED: EoEventDescription;
    pub static _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL: EoEventDescription;
    pub static _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_START:
               EoEventDescription;
    pub static _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_ANIM_STOP:
               EoEventDescription;
    pub static _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_START:
               EoEventDescription;
    pub static _EVAS_SCROLLABLE_INTERFACE_EVENT_SCROLL_DRAG_STOP:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTED:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_UNSELECTED:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_PASTE:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_COPY:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CUT:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_START:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CHANGED:
               EoEventDescription;
    pub static _EVAS_SELECTABLE_INTERFACE_EVENT_SELECTION_CLEARED:
               EoEventDescription;
    pub static _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_START:
               EoEventDescription;
    pub static _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_STOP: EoEventDescription;
    pub static _EVAS_ZOOMABLE_INTERFACE_EVENT_ZOOM_CHANGE:
               EoEventDescription;
    pub static _EVAS_BOX_EVENT_CHILD_ADDED: EoEventDescription;
    pub static _EVAS_BOX_EVENT_CHILD_REMOVED: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_IN: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_OUT: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_DOWN: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_UP: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_MOVE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOUSE_WHEEL: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MULTI_DOWN: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MULTI_UP: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MULTI_MOVE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_FREE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_KEY_DOWN: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_KEY_UP: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_FOCUS_IN: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_FOCUS_OUT: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_SHOW: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_HIDE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_MOVE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_RESIZE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_RESTACK: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_DEL: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_HOLD: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_CHANGED_SIZE_HINTS: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_IMAGE_PRELOADED: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_IMAGE_RESIZE: EoEventDescription;
    pub static _EVAS_OBJECT_EVENT_IMAGE_UNLOADED: EoEventDescription;
    pub static _EVAS_CANVAS3D_OBJECT_EVENT_CLICKED: EoEventDescription;
    pub static _EVAS_CANVAS3D_OBJECT_EVENT_COLLISION: EoEventDescription;
}
#[link(name = "evas")]
extern "C" {
//----------------------------------------------------------------------------------------------
// Evas Common
//----------------------------------------------------------------------------------------------
    pub fn evas_module_register(module: *const EvasModuleApi,
                                _type: EvasModuleType) -> EinaBool;
    pub fn evas_module_unregister(module: *const EvasModuleApi,
                                  _type: EvasModuleType) -> EinaBool;
    pub fn evas_cserve_path_get() -> *const c_char;
    pub fn evas_init() -> c_int;
    pub fn evas_shutdown() -> c_int;
    pub fn evas_alloc_error() -> EvasAllocError;
    pub fn evas_async_events_fd_get() -> c_int;
    pub fn evas_async_events_process() -> c_int;
    pub fn evas_async_events_put(target: *const c_void,
                                 _type: EvasCallbackType,
                                 event_info: *mut c_void,
                                 func: EvasAsyncEventsPutCb) -> EinaBool;
    pub fn evas_render_method_lookup(name: *const c_char)
     -> c_int;
    pub fn evas_render_method_list() -> *mut EinaList;
    pub fn evas_render_method_list_free(list: *mut EinaList);
    pub fn evas_render_updates_free(updates: *mut EinaList);
    pub fn evas_device_add(e: *mut Evas) -> *mut EvasDevice;
    pub fn evas_device_del(dev: *mut EvasDevice);
    pub fn evas_device_push(e: *mut Evas, dev: *mut EvasDevice);
    pub fn evas_device_pop(e: *mut Evas);
    pub fn evas_device_list(e: *mut Evas, dev: *const EvasDevice)
     -> *const EinaList;
    pub fn evas_device_name_set(dev: *mut EvasDevice,
                                name: *const c_char);
    pub fn evas_device_name_get(dev: *const EvasDevice)
     -> *const c_char;
    pub fn evas_device_description_set(dev: *mut EvasDevice,
                                       desc: *const c_char);
    pub fn evas_device_description_get(dev: *const EvasDevice)
     -> *const c_char;
    pub fn evas_device_parent_set(dev: *mut EvasDevice,
                                  parent: *mut EvasDevice);
    pub fn evas_device_parent_get(dev: *const EvasDevice)
     -> *const EvasDevice;
    pub fn evas_device_class_set(dev: *mut EvasDevice,
                                 clas: EvasDeviceClass);
    pub fn evas_device_class_get(dev: *const EvasDevice)
     -> EvasDeviceClass;
    pub fn evas_device_subclass_set(dev: *mut EvasDevice,
                                    clas: EvasDeviceSubclass);
    pub fn evas_device_subclass_get(dev: *const EvasDevice)
     -> EvasDeviceSubclass;
    pub fn evas_device_emulation_source_set(dev: *mut EvasDevice,
                                            src: *mut EvasDevice);
    pub fn evas_device_emulation_source_get(dev: *const EvasDevice)
     -> *const EvasDevice;
    pub fn evas_map_util_points_populate_from_object_full(m: *mut EvasMap,
                                                          obj:
                                                              *const EvasObject,
                                                          z: EvasCoord);
    pub fn evas_map_util_points_populate_from_object(m: *mut EvasMap,
                                                     obj: *const EvasObject);
    pub fn evas_map_util_points_populate_from_geometry(m: *mut EvasMap,
                                                       x: EvasCoord,
                                                       y: EvasCoord,
                                                       w: EvasCoord,
                                                       h: EvasCoord,
                                                       z: EvasCoord);
    pub fn evas_map_util_points_color_set(m: *mut EvasMap,
                                          r: c_int,
                                          g: c_int,
                                          b: c_int,
                                          a: c_int);
    pub fn evas_map_util_rotate(m: *mut EvasMap,
                                degrees: c_double,
                                cx: EvasCoord, cy: EvasCoord);
    pub fn evas_map_util_zoom(m: *mut EvasMap,
                              zoomx: c_double,
                              zoomy: c_double, cx: EvasCoord,
                              cy: EvasCoord);
    pub fn evas_map_util_3d_rotate(m: *mut EvasMap,
                                   dx: c_double,
                                   dy: c_double,
                                   dz: c_double,
                                   cx: EvasCoord, cy: EvasCoord,
                                   cz: EvasCoord);
    pub fn evas_map_util_quat_rotate(m: *mut EvasMap,
                                     qx: c_double,
                                     qy: c_double,
                                     qz: c_double,
                                     qw: c_double,
                                     cx: c_double,
                                     cy: c_double,
                                     cz: c_double);
    pub fn evas_map_util_3d_lighting(m: *mut EvasMap, lx: EvasCoord,
                                     ly: EvasCoord, lz: EvasCoord,
                                     lr: c_int,
                                     lg: c_int,
                                     lb: c_int,
                                     ar: c_int,
                                     ag: c_int,
                                     ab: c_int);
    pub fn evas_map_util_3d_perspective(m: *mut EvasMap, px: EvasCoord,
                                        py: EvasCoord, z0: EvasCoord,
                                        foc: EvasCoord);
    pub fn evas_map_util_clockwise_get(m: *mut EvasMap) -> EinaBool;
    pub fn evas_map_new(count: c_int) -> *mut EvasMap;
    pub fn evas_map_smooth_set(m: *mut EvasMap, enabled: EinaBool);
    pub fn evas_map_smooth_get(m: *const EvasMap) -> EinaBool;
    pub fn evas_map_alpha_set(m: *mut EvasMap, enabled: EinaBool);
    pub fn evas_map_alpha_get(m: *const EvasMap) -> EinaBool;
    pub fn evas_map_util_object_move_sync_set(m: *mut EvasMap,
                                              enabled: EinaBool);
    pub fn evas_map_util_object_move_sync_get(m: *const EvasMap)
     -> EinaBool;
    pub fn evas_map_dup(m: *const EvasMap) -> *mut EvasMap;
    pub fn evas_map_free(m: *mut EvasMap);
    pub fn evas_map_count_get(m: *const EvasMap) -> c_int;
    pub fn evas_map_point_coord_set(m: *mut EvasMap,
                                    idx: c_int, x: EvasCoord,
                                    y: EvasCoord, z: EvasCoord);
    pub fn evas_map_point_coord_get(m: *const EvasMap,
                                    idx: c_int,
                                    x: *mut EvasCoord, y: *mut EvasCoord,
                                    z: *mut EvasCoord);
    pub fn evas_map_point_image_uv_set(m: *mut EvasMap,
                                       idx: c_int,
                                       u: c_double,
                                       v: c_double);
    pub fn evas_map_point_image_uv_get(m: *const EvasMap,
                                       idx: c_int,
                                       u: *mut c_double,
                                       v: *mut c_double);
    pub fn evas_map_point_color_set(m: *mut EvasMap,
                                    idx: c_int,
                                    r: c_int,
                                    g: c_int,
                                    b: c_int,
                                    a: c_int);
    pub fn evas_map_point_color_get(m: *const EvasMap,
                                    idx: c_int,
                                    r: *mut c_int,
                                    g: *mut c_int,
                                    b: *mut c_int,
                                    a: *mut c_int);
    pub fn evas_object_image_extension_can_load_get(file:
                                                        *const c_char)
     -> EinaBool;
    pub fn evas_object_image_extension_can_load_fast_get(file:
                                                             *const c_char)
     -> EinaBool;
    pub fn evas_textblock_escape_string_get(escape:
                                                *const c_char)
     -> *const c_char;
    pub fn evas_textblock_string_escape_get(string:
                                                *const c_char,
                                            len_ret:
                                                *mut c_int)
     -> *const c_char;
    pub fn evas_textblock_escape_string_range_get(escape_start:
                                                      *const c_char,
                                                  escape_end:
                                                      *const c_char)
     -> *const c_char;
    pub fn evas_textblock_style_new() -> *mut EvasTextblockStyle;
    pub fn evas_textblock_style_free(ts: *mut EvasTextblockStyle);
    pub fn evas_textblock_style_set(ts: *mut EvasTextblockStyle,
                                    text: *const c_char);
    pub fn evas_textblock_style_get(ts: *const EvasTextblockStyle)
     -> *const c_char;
    pub fn evas_object_textblock_text_markup_prepend(cur:
                                                         *mut EvasTextblockCursor,
                                                     text:
                                                         *const c_char);
    pub fn evas_textblock_cursor_free(cur: *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_paragraph_first(cur:
                                                     *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_paragraph_last(cur:
                                                    *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_paragraph_next(cur:
                                                    *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_paragraph_prev(cur:
                                                    *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_node_format_next_get(n:
                                                   *const EvasObjectTextblockNodeFormat)
     -> *const EvasObjectTextblockNodeFormat;
    pub fn evas_textblock_node_format_prev_get(n:
                                                   *const EvasObjectTextblockNodeFormat)
     -> *const EvasObjectTextblockNodeFormat;
    pub fn evas_textblock_cursor_set_at_format(cur:
                                                   *mut EvasTextblockCursor,
                                               n:
                                                   *const EvasObjectTextblockNodeFormat);
    pub fn evas_textblock_cursor_format_get(cur: *const EvasTextblockCursor)
     -> *const EvasObjectTextblockNodeFormat;
    pub fn evas_textblock_node_format_text_get(fnode:
                                                   *const EvasObjectTextblockNodeFormat)
     -> *const c_char;
    pub fn evas_textblock_cursor_at_format_set(cur:
                                                   *mut EvasTextblockCursor,
                                               fmt:
                                                   *const EvasObjectTextblockNodeFormat);
    pub fn evas_textblock_cursor_format_is_visible_get(cur:
                                                           *const EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_format_next(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_format_prev(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_is_format(cur: *const EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_char_next(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_char_prev(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_word_start(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_word_end(cur: *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_paragraph_char_first(cur:
                                                          *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_paragraph_char_last(cur:
                                                         *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_line_char_first(cur:
                                                     *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_line_char_last(cur:
                                                    *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_pos_get(cur: *const EvasTextblockCursor)
     -> c_int;
    pub fn evas_textblock_cursor_pos_set(cur: *mut EvasTextblockCursor,
                                         pos: c_int);
    pub fn evas_textblock_cursor_line_set(cur: *mut EvasTextblockCursor,
                                          line: c_int)
     -> EinaBool;
    pub fn evas_textblock_cursor_compare(cur1: *const EvasTextblockCursor,
                                         cur2: *const EvasTextblockCursor)
     -> c_int;
    pub fn evas_textblock_cursor_copy(cur: *const EvasTextblockCursor,
                                      cur_dest: *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_text_append(cur: *mut EvasTextblockCursor,
                                             text:
                                                 *const c_char)
     -> c_int;
    pub fn evas_textblock_cursor_text_prepend(cur: *mut EvasTextblockCursor,
                                              text:
                                                  *const c_char)
     -> c_int;
    pub fn evas_textblock_cursor_format_append(cur:
                                                   *mut EvasTextblockCursor,
                                               format:
                                                   *const c_char)
     -> EinaBool;
    pub fn evas_textblock_cursor_format_prepend(cur:
                                                    *mut EvasTextblockCursor,
                                                format:
                                                    *const c_char)
     -> EinaBool;
    pub fn evas_textblock_cursor_char_delete(cur: *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_range_delete(cur1:
                                                  *mut EvasTextblockCursor,
                                              cur2:
                                                  *mut EvasTextblockCursor);
    pub fn evas_textblock_cursor_paragraph_text_get(cur:
                                                        *const EvasTextblockCursor)
     -> *const c_char;
    pub fn evas_textblock_cursor_paragraph_text_length_get(cur:
                                                               *const EvasTextblockCursor)
     -> c_int;
    pub fn evas_textblock_cursor_visible_range_get(start:
                                                       *mut EvasTextblockCursor,
                                                   end:
                                                       *mut EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_textblock_cursor_range_formats_get(cur1:
                                                       *const EvasTextblockCursor,
                                                   cur2:
                                                       *const EvasTextblockCursor)
     -> *mut EinaList;
    pub fn evas_textblock_cursor_range_text_get(cur1:
                                                    *const EvasTextblockCursor,
                                                cur2:
                                                    *const EvasTextblockCursor,
                                                format:
                                                    EvasTextblockTextType)
     -> *mut c_char;
    pub fn evas_textblock_cursor_content_get(cur:
                                                 *const EvasTextblockCursor)
     -> *mut c_char;
    pub fn evas_textblock_cursor_geometry_bidi_get(cur:
                                                       *const EvasTextblockCursor,
                                                   cx: *mut EvasCoord,
                                                   cy: *mut EvasCoord,
                                                   cw: *mut EvasCoord,
                                                   ch: *mut EvasCoord,
                                                   cx2: *mut EvasCoord,
                                                   cy2: *mut EvasCoord,
                                                   cw2: *mut EvasCoord,
                                                   ch2: *mut EvasCoord,
                                                   ctype:
                                                       EvasTextblockCursorType)
     -> EinaBool;
    pub fn evas_textblock_cursor_geometry_get(cur:
                                                  *const EvasTextblockCursor,
                                              cx: *mut EvasCoord,
                                              cy: *mut EvasCoord,
                                              cw: *mut EvasCoord,
                                              ch: *mut EvasCoord,
                                              dir: *mut EvasBidiDirection,
                                              ctype:
                                                  EvasTextblockCursorType)
     -> c_int;
    pub fn evas_textblock_cursor_char_geometry_get(cur:
                                                       *const EvasTextblockCursor,
                                                   cx: *mut EvasCoord,
                                                   cy: *mut EvasCoord,
                                                   cw: *mut EvasCoord,
                                                   ch: *mut EvasCoord)
     -> c_int;
    pub fn evas_textblock_cursor_pen_geometry_get(cur:
                                                      *const EvasTextblockCursor,
                                                  cpen_x: *mut EvasCoord,
                                                  cy: *mut EvasCoord,
                                                  cadv: *mut EvasCoord,
                                                  ch: *mut EvasCoord)
     -> c_int;
    pub fn evas_textblock_cursor_line_geometry_get(cur:
                                                       *const EvasTextblockCursor,
                                                   cx: *mut EvasCoord,
                                                   cy: *mut EvasCoord,
                                                   cw: *mut EvasCoord,
                                                   ch: *mut EvasCoord)
     -> c_int;
    pub fn evas_textblock_cursor_char_coord_set(cur:
                                                    *mut EvasTextblockCursor,
                                                x: EvasCoord, y: EvasCoord)
     -> EinaBool;
    pub fn evas_textblock_cursor_line_coord_set(cur:
                                                    *mut EvasTextblockCursor,
                                                y: EvasCoord)
     -> c_int;
    pub fn evas_textblock_cursor_range_geometry_get(cur1:
                                                        *const EvasTextblockCursor,
                                                    cur2:
                                                        *const EvasTextblockCursor)
     -> *mut EinaList;
    pub fn evas_textblock_cursor_range_simple_geometry_get(cur1:
                                                               *const EvasTextblockCursor,
                                                           cur2:
                                                               *const EvasTextblockCursor)
     -> *mut EinaIterator;
    pub fn evas_textblock_cursor_format_item_geometry_get(cur:
                                                              *const EvasTextblockCursor,
                                                          cx: *mut EvasCoord,
                                                          cy: *mut EvasCoord,
                                                          cw: *mut EvasCoord,
                                                          ch: *mut EvasCoord)
     -> EinaBool;
    pub fn evas_textblock_cursor_eol_get(cur: *const EvasTextblockCursor)
     -> EinaBool;
    pub fn evas_smart_free(s: *mut EvasSmart);
    pub fn evas_smart_class_new(sc: *const EvasSmartClass)
     -> *mut EvasSmart;
    pub fn evas_smart_class_get(s: *const EvasSmart)
     -> *const EvasSmartClass;
    pub fn evas_smart_data_get(s: *const EvasSmart)
     -> *mut c_void;
    pub fn evas_smart_callbacks_descriptions_get(s: *const EvasSmart,
                                                 count:
                                                     *mut c_uint)
     -> *mut *const EvasSmartCbDescription;
    pub fn evas_smart_callback_description_find(s: *const EvasSmart,
                                                name:
                                                    *const c_char)
     -> *const EvasSmartCbDescription;
    pub fn evas_smart_class_inherit_full(sc: *mut EvasSmartClass,
                                         parent_sc: *const EvasSmartClass,
                                         parent_sc_size:
                                             c_uint)
     -> EinaBool;
    pub fn evas_smart_usage_get(s: *const EvasSmart)
     -> c_int;
    pub fn evas_smart_legacy_type_register(_type:
                                               *const c_char,
                                           klass: *const EoClass);
    pub fn evas_object_smart_clipped_smart_set(sc: *mut EvasSmartClass);
    pub fn evas_object_smart_clipped_class_get() -> *const EvasSmartClass;
    pub fn evas_object_box_smart_set(api: *mut EvasObjectBoxApi);
    pub fn evas_object_box_smart_class_get() -> *const EvasObjectBoxApi;
    pub fn evas_cserve_want_get() -> EinaBool;
    pub fn evas_cserve_connected_get() -> EinaBool;
    pub fn evas_cserve_stats_get(stats: *mut EvasCserveStats) -> EinaBool;
    pub fn evas_cserve_image_cache_contents_clean(cache:
                                                      *mut EvasCserveImageCache);
    pub fn evas_cserve_config_get(config: *mut EvasCserveConfig)
     -> EinaBool;
    pub fn evas_cserve_config_set(config: *const EvasCserveConfig)
     -> EinaBool;
    pub fn evas_cserve_disconnect();
    pub fn evas_load_error_str(error: EvasLoadError)
     -> *const c_char;
    pub fn evas_color_hsv_to_rgb(h: c_float,
                                 s: c_float,
                                 v: c_float,
                                 r: *mut c_int,
                                 g: *mut c_int,
                                 b: *mut c_int);
    pub fn evas_color_rgb_to_hsv(r: c_int,
                                 g: c_int,
                                 b: c_int,
                                 h: *mut c_float,
                                 s: *mut c_float,
                                 v: *mut c_float);
    pub fn evas_color_argb_premul(a: c_int,
                                  r: *mut c_int,
                                  g: *mut c_int,
                                  b: *mut c_int);
    pub fn evas_color_argb_unpremul(a: c_int,
                                    r: *mut c_int,
                                    g: *mut c_int,
                                    b: *mut c_int);
    pub fn evas_data_argb_premul(data: *mut c_uint,
                                 len: c_uint);
    pub fn evas_data_argb_unpremul(data: *mut c_uint,
                                   len: c_uint);
    pub fn evas_string_char_next_get(str: *const c_char,
                                     pos: c_int,
                                     decoded: *mut c_int)
     -> c_int;
    pub fn evas_string_char_prev_get(str: *const c_char,
                                     pos: c_int,
                                     decoded: *mut c_int)
     -> c_int;
    pub fn evas_string_char_len_get(str: *const c_char)
     -> c_int;
    pub fn evas_key_modifier_is_set(m: *const EvasModifier,
                                    keyname: *const c_char)
     -> EinaBool;
    pub fn evas_key_lock_is_set(l: *const EvasLock,
                                keyname: *const c_char)
     -> EinaBool;
    pub fn evas_font_path_global_clear();
    pub fn evas_font_path_global_append(path: *const c_char);
    pub fn evas_font_path_global_prepend(path: *const c_char);
    pub fn evas_font_path_global_list() -> *const EinaList;
    pub fn evas_font_reinit();
//------------------------------------------------------------------------------------------------
// Evas Legacy
//------------------------------------------------------------------------------------------------
    pub fn evas_new() -> *mut Evas;
    pub fn evas_free(e: *mut Evas);
    pub fn evas_output_framespace_set(obj: *mut EvasCanvas, x: EvasCoord,
                                      y: EvasCoord, w: EvasCoord,
                                      h: EvasCoord);
    pub fn evas_output_framespace_get(obj: *const EvasCanvas,
                                      x: *mut EvasCoord, y: *mut EvasCoord,
                                      w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_output_viewport_set(obj: *mut EvasCanvas, x: EvasCoord,
                                    y: EvasCoord, w: EvasCoord,
                                    h: EvasCoord);
    pub fn evas_output_viewport_get(obj: *const EvasCanvas,
                                    x: *mut EvasCoord, y: *mut EvasCoord,
                                    w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_image_cache_set(obj: *mut EvasCanvas,
                                size: c_int);
    pub fn evas_image_cache_get(obj: *const EvasCanvas)
     -> c_int;
    pub fn evas_event_default_flags_set(obj: *mut EvasCanvas,
                                        flags: EvasEventFlags);
    pub fn evas_event_default_flags_get(obj: *const EvasCanvas)
     -> EvasEventFlags;
    pub fn evas_output_method_set(obj: *mut EvasCanvas,
                                  render_method: c_int);
    pub fn evas_output_method_get(obj: *const EvasCanvas)
     -> c_int;
    pub fn evas_font_cache_set(obj: *mut EvasCanvas,
                               size: c_int);
    pub fn evas_font_cache_get(obj: *const EvasCanvas)
     -> c_int;
    pub fn evas_output_size_set(obj: *mut EvasCanvas,
                                w: c_int,
                                h: c_int);
    pub fn evas_output_size_get(obj: *const EvasCanvas,
                                w: *mut c_int,
                                h: *mut c_int);
    pub fn evas_data_attach_set(obj: *mut EvasCanvas,
                                data: *mut c_void);
    pub fn evas_data_attach_get(obj: *const EvasCanvas)
     -> *mut c_void;
    pub fn evas_font_hinting_set(obj: *mut EvasCanvas,
                                 hinting: EvasFontHintingFlags);
    pub fn evas_font_hinting_get(obj: *const EvasCanvas)
     -> EvasFontHintingFlags;
    pub fn evas_engine_info_set(obj: *mut EvasCanvas,
                                info: *mut EvasEngineInfo) -> EinaBool;
    pub fn evas_engine_info_get(obj: *const EvasCanvas)
     -> *mut EvasEngineInfo;
    pub fn evas_focus_get(obj: *const EvasCanvas) -> *mut EvasObject;
    pub fn evas_object_top_get(obj: *const EvasCanvas) -> *mut EvasObject;
    pub fn evas_key_lock_get(obj: *const EvasCanvas) -> *const EvasLock;
    pub fn evas_pointer_canvas_xy_get(obj: *const EvasCanvas,
                                      x: *mut EvasCoord, y: *mut EvasCoord);
    pub fn evas_event_down_count_get(obj: *const EvasCanvas)
     -> c_int;
    pub fn evas_smart_objects_calculate_count_get(e: *const Evas)
     -> c_int;
    pub fn evas_focus_state_get(obj: *const EvasCanvas) -> EinaBool;
    pub fn evas_changed_get(obj: *const EvasCanvas) -> EinaBool;
    pub fn evas_pointer_output_xy_get(obj: *const EvasCanvas,
                                      x: *mut c_int,
                                      y: *mut c_int);
    pub fn evas_pointer_inside_get(obj: *const EvasCanvas) -> EinaBool;
    pub fn evas_image_max_size_get(obj: *const EvasCanvas,
                                   maxw: *mut c_int,
                                   maxh: *mut c_int)
     -> EinaBool;
    pub fn evas_object_bottom_get(obj: *const EvasCanvas)
     -> *mut EvasObject;
    pub fn evas_key_modifier_get(obj: *const EvasCanvas)
     -> *const EvasModifier;
    pub fn evas_pointer_button_down_mask_get(obj: *const EvasCanvas)
     -> c_int;
    pub fn evas_tree_objects_at_xy_get(obj: *mut EvasCanvas,
                                       stop: *mut EvasObject,
                                       x: c_int,
                                       y: c_int)
     -> *mut EinaList;
    pub fn evas_event_feed_mouse_wheel(obj: *mut EvasCanvas,
                                       direction: c_int,
                                       z: c_int,
                                       timestamp: c_uint,
                                       data: *const c_void);
    pub fn evas_key_lock_on(obj: *mut EvasCanvas,
                            keyname: *const c_char);
    pub fn evas_event_feed_key_down(obj: *mut EvasCanvas,
                                    keyname: *const c_char,
                                    key: *const c_char,
                                    string: *const c_char,
                                    compose: *const c_char,
                                    timestamp: c_uint,
                                    data: *const c_void);
    pub fn evas_key_modifier_mask_get(obj: *const EvasCanvas,
                                      keyname: *const c_char)
     -> EvasModifierMask;
    pub fn evas_key_modifier_add(obj: *mut EvasCanvas,
                                 keyname: *const c_char);
    pub fn evas_key_modifier_off(obj: *mut EvasCanvas,
                                 keyname: *const c_char);
    pub fn evas_event_feed_hold(obj: *mut EvasCanvas,
                                hold: c_int,
                                timestamp: c_uint,
                                data: *const c_void);
    pub fn evas_event_feed_mouse_move(obj: *mut EvasCanvas,
                                      x: c_int,
                                      y: c_int,
                                      timestamp: c_uint,
                                      data: *const c_void);
    pub fn evas_event_feed_key_up(obj: *mut EvasCanvas,
                                  keyname: *const c_char,
                                  key: *const c_char,
                                  string: *const c_char,
                                  compose: *const c_char,
                                  timestamp: c_uint,
                                  data: *const c_void);
    pub fn evas_event_feed_mouse_out(obj: *mut EvasCanvas,
                                     timestamp: c_uint,
                                     data: *const c_void);
    pub fn evas_event_input_multi_move(obj: *mut EvasCanvas,
                                       d: c_int,
                                       x: c_int,
                                       y: c_int,
                                       rad: c_double,
                                       radx: c_double,
                                       rady: c_double,
                                       pres: c_double,
                                       ang: c_double,
                                       fx: c_double,
                                       fy: c_double,
                                       timestamp: c_uint,
                                       data: *const c_void);
    pub fn evas_objects_at_xy_get(obj: *const EvasCanvas, x: EvasCoord,
                                  y: EvasCoord,
                                  include_pass_events_objects: EinaBool,
                                  include_hidden_objects: EinaBool)
     -> *mut EinaList;
    pub fn evas_event_input_multi_up(obj: *mut EvasCanvas,
                                     d: c_int,
                                     x: c_int,
                                     y: c_int,
                                     rad: c_double,
                                     radx: c_double,
                                     rady: c_double,
                                     pres: c_double,
                                     ang: c_double,
                                     fx: c_double,
                                     fy: c_double,
                                     flags: EvasButtonFlags,
                                     timestamp: c_uint,
                                     data: *const c_void);
    pub fn evas_event_feed_multi_down(obj: *mut EvasCanvas,
                                      d: c_int,
                                      x: c_int,
                                      y: c_int,
                                      rad: c_double,
                                      radx: c_double,
                                      rady: c_double,
                                      pres: c_double,
                                      ang: c_double,
                                      fx: c_double,
                                      fy: c_double,
                                      flags: EvasButtonFlags,
                                      timestamp: c_uint,
                                      data: *const c_void);
    pub fn evas_render_async(obj: *mut EvasCanvas) -> EinaBool;
    pub fn evas_render2(obj: *mut EvasCanvas) -> EinaBool;
    pub fn evas_render2_updates(obj: *mut EvasCanvas) -> *mut EinaList;
    pub fn evas_focus_out(obj: *mut EvasCanvas);
    pub fn evas_event_input_mouse_move(obj: *mut EvasCanvas,
                                       x: c_int,
                                       y: c_int,
                                       timestamp: c_uint,
                                       data: *const c_void);
    pub fn evas_norender(obj: *mut EvasCanvas);
    pub fn evas_touch_point_list_count(obj: *mut EvasCanvas)
     -> c_uint;
    pub fn evas_event_input_multi_down(obj: *mut EvasCanvas,
                                       d: c_int,
                                       x: c_int,
                                       y: c_int,
                                       rad: c_double,
                                       radx: c_double,
                                       rady: c_double,
                                       pres: c_double,
                                       ang: c_double,
                                       fx: c_double,
                                       fy: c_double,
                                       flags: EvasButtonFlags,
                                       timestamp: c_uint,
                                       data: *const c_void);
    pub fn evas_nochange_pop(obj: *mut EvasCanvas);
    pub fn evas_key_lock_off(obj: *mut EvasCanvas,
                             keyname: *const c_char);
    pub fn evas_nochange_push(obj: *mut EvasCanvas);
    pub fn evas_font_cache_flush(obj: *mut EvasCanvas);
    pub fn evas_font_hinting_can_hint(obj: *const EvasCanvas,
                                      hinting: EvasFontHintingFlags)
     -> EinaBool;
    pub fn evas_object_top_at_xy_get(obj: *const EvasCanvas, x: EvasCoord,
                                     y: EvasCoord,
                                     include_pass_events_objects: EinaBool,
                                     include_hidden_objects: EinaBool)
     -> *mut EvasObject;
    pub fn evas_key_modifier_on(obj: *mut EvasCanvas,
                                keyname: *const c_char);
    pub fn evas_event_feed_mouse_up(obj: *mut EvasCanvas,
                                    b: c_int,
                                    flags: EvasButtonFlags,
                                    timestamp: c_uint,
                                    data: *const c_void);
    pub fn evas_event_feed_mouse_down(obj: *mut EvasCanvas,
                                      b: c_int,
                                      flags: EvasButtonFlags,
                                      timestamp: c_uint,
                                      data: *const c_void);
    pub fn evas_event_refeed_event(obj: *mut EvasCanvas,
                                   event_copy: *mut c_void,
                                   event_type: EvasCallbackType);
    pub fn evas_font_available_list(obj: *const EvasCanvas)
     -> *mut EinaList;
    pub fn evas_objects_in_rectangle_get(obj: *const EvasCanvas,
                                         x: EvasCoord, y: EvasCoord,
                                         w: EvasCoord, h: EvasCoord,
                                         include_pass_events_objects:
                                             EinaBool,
                                         include_hidden_objects: EinaBool)
     -> *mut EinaList;
    pub fn evas_object_name_find(obj: *const EvasCanvas,
                                 name: *const c_char)
     -> *mut EvasObject;
    pub fn evas_font_path_append(obj: *mut EvasCanvas,
                                 path: *const c_char);
    pub fn evas_touch_point_list_nth_id_get(obj: *mut EvasCanvas,
                                            n: c_uint)
     -> c_int;
    pub fn evas_font_path_clear(obj: *mut EvasCanvas);
    pub fn evas_smart_objects_calculate(obj: *mut EvasCanvas);
    pub fn evas_touch_point_list_nth_xy_get(obj: *mut EvasCanvas,
                                            n: c_uint,
                                            x: *mut EvasCoord,
                                            y: *mut EvasCoord);
    pub fn evas_key_lock_del(obj: *mut EvasCanvas,
                             keyname: *const c_char);
    pub fn evas_damage_rectangle_add(obj: *mut EvasCanvas,
                                     x: c_int,
                                     y: c_int,
                                     w: c_int,
                                     h: c_int);
    pub fn evas_sync(obj: *mut EvasCanvas);
    pub fn evas_font_path_list(obj: *const EvasCanvas) -> *const EinaList;
    pub fn evas_image_cache_reload(obj: *mut EvasCanvas);
    pub fn evas_coord_world_x_to_screen(obj: *const EvasCanvas,
                                        x: EvasCoord)
     -> c_int;
    pub fn evas_event_feed_multi_move(obj: *mut EvasCanvas,
                                      d: c_int,
                                      x: c_int,
                                      y: c_int,
                                      rad: c_double,
                                      radx: c_double,
                                      rady: c_double,
                                      pres: c_double,
                                      ang: c_double,
                                      fx: c_double,
                                      fy: c_double,
                                      timestamp: c_uint,
                                      data: *const c_void);
    pub fn evas_render_updates(obj: *mut EvasCanvas) -> *mut EinaList;
    pub fn evas_image_cache_flush(obj: *mut EvasCanvas);
    pub fn evas_coord_screen_y_to_world(obj: *const EvasCanvas,
                                        y: c_int)
     -> EvasCoord;
    pub fn evas_key_modifier_del(obj: *mut EvasCanvas,
                                 keyname: *const c_char);
    pub fn evas_touch_point_list_nth_state_get(obj: *mut EvasCanvas,
                                               n: c_uint)
     -> EvasTouchPointState;
    pub fn evas_focus_in(obj: *mut EvasCanvas);
    pub fn evas_obscured_rectangle_add(obj: *mut EvasCanvas,
                                       x: c_int,
                                       y: c_int,
                                       w: c_int,
                                       h: c_int);
    pub fn evas_render_dump(obj: *mut EvasCanvas);
    pub fn evas_event_feed_mouse_in(obj: *mut EvasCanvas,
                                    timestamp: c_uint,
                                    data: *const c_void);
    pub fn evas_object_top_in_rectangle_get(obj: *const EvasCanvas,
                                            x: EvasCoord, y: EvasCoord,
                                            w: EvasCoord, h: EvasCoord,
                                            include_pass_events_objects:
                                                EinaBool,
                                            include_hidden_objects: EinaBool)
     -> *mut EvasObject;
    pub fn evas_render(obj: *mut EvasCanvas);
    pub fn evas_event_feed_multi_up(obj: *mut EvasCanvas,
                                    d: c_int,
                                    x: c_int,
                                    y: c_int,
                                    rad: c_double,
                                    radx: c_double,
                                    rady: c_double,
                                    pres: c_double,
                                    ang: c_double,
                                    fx: c_double,
                                    fy: c_double,
                                    flags: EvasButtonFlags,
                                    timestamp: c_uint,
                                    data: *const c_void);
    pub fn evas_font_path_prepend(obj: *mut EvasCanvas,
                                  path: *const c_char);
    pub fn evas_obscured_clear(obj: *mut EvasCanvas);
    pub fn evas_event_feed_mouse_cancel(obj: *mut EvasCanvas,
                                        timestamp: c_uint,
                                        data: *const c_void);
    pub fn evas_coord_screen_x_to_world(obj: *const EvasCanvas,
                                        x: c_int)
     -> EvasCoord;
    pub fn evas_key_lock_add(obj: *mut EvasCanvas,
                             keyname: *const c_char);
    pub fn evas_render_idle_flush(obj: *mut EvasCanvas);
    pub fn evas_coord_world_y_to_screen(obj: *const EvasCanvas,
                                        y: EvasCoord)
     -> c_int;
    pub fn evas_event_feed_key_down_with_keycode(obj: *mut EvasCanvas,
                                                 keyname:
                                                     *const c_char,
                                                 key:
                                                     *const c_char,
                                                 string:
                                                     *const c_char,
                                                 compose:
                                                     *const c_char,
                                                 timestamp:
                                                     c_uint,
                                                 data:
                                                     *const c_void,
                                                 keycode:
                                                     c_uint);
    pub fn evas_event_feed_key_up_with_keycode(obj: *mut EvasCanvas,
                                               keyname:
                                                   *const c_char,
                                               key:
                                                   *const c_char,
                                               string:
                                                   *const c_char,
                                               compose:
                                                   *const c_char,
                                               timestamp:
                                                   c_uint,
                                               data:
                                                   *const c_void,
                                               keycode:
                                                   c_uint);
    pub fn evas_event_feed_axis_update(obj: *mut EvasCanvas,
                                       timestamp: c_uint,
                                       device: c_int,
                                       toolid: c_int,
                                       naxes: c_int,
                                       axis: *const EvasAxis,
                                       data: *const c_void);
    pub fn evas_event_callback_add(e: *mut Evas, _type: EvasCallbackType,
                                   func: EvasEventCb,
                                   data: *const c_void);
    pub fn evas_event_callback_priority_add(e: *mut Evas,
                                            _type: EvasCallbackType,
                                            priority: EvasCallbackPriority,
                                            func: EvasEventCb,
                                            data:
                                                *const c_void);
    pub fn evas_event_callback_del(e: *mut Evas, _type: EvasCallbackType,
                                   func: EvasEventCb)
     -> *mut c_void;
    pub fn evas_event_callback_del_full(e: *mut Evas,
                                        _type: EvasCallbackType,
                                        func: EvasEventCb,
                                        data: *const c_void)
     -> *mut c_void;
    pub fn evas_post_event_callback_push(e: *mut Evas,
                                         func: EvasObjectEventPostCb,
                                         data: *const c_void);
    pub fn evas_post_event_callback_remove(e: *mut Evas,
                                           func: EvasObjectEventPostCb);
    pub fn evas_post_event_callback_remove_full(e: *mut Evas,
                                                func:
                                                    EvasObjectEventPostCb,
                                                data:
                                                    *const c_void);
    pub fn evas_event_freeze(e: *mut Evas);
    pub fn evas_event_thaw(e: *mut Evas);
    pub fn evas_event_freeze_get(e: *const Evas) -> c_int;
    pub fn evas_event_thaw_eval(e: *mut Evas);
    pub fn evas_font_available_list_free(e: *mut Evas,
                                         available: *mut EinaList);
    pub fn evas_object_ref(obj: *mut EvasObject);
    pub fn evas_object_unref(obj: *mut EvasObject);
    pub fn evas_object_ref_get(obj: *const EvasObject)
     -> c_int;
    pub fn evas_object_del(obj: *mut EvasObject);
    pub fn evas_object_geometry_get(obj: *const EvasObject,
                                    x: *mut EvasCoord, y: *mut EvasCoord,
                                    w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_object_geometry_set(obj: *mut EvasObject, x: EvasCoord,
                                    y: EvasCoord, w: EvasCoord,
                                    h: EvasCoord);
    pub fn evas_object_show(obj: *mut EvasObject);
    pub fn evas_object_hide(obj: *mut EvasObject);
    pub fn evas_object_color_set(obj: *mut EvasObject,
                                 r: c_int,
                                 g: c_int,
                                 b: c_int,
                                 a: c_int);
    pub fn evas_object_color_get(obj: *const EvasObject,
                                 r: *mut c_int,
                                 g: *mut c_int,
                                 b: *mut c_int,
                                 a: *mut c_int);
    pub fn evas_object_move(obj: *mut EvasObject, x: EvasCoord,
                            y: EvasCoord);
    pub fn evas_object_resize(obj: *mut EvasObject, w: EvasCoord,
                              h: EvasCoord);
    pub fn evas_object_visible_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_layer_set(obj: *mut EvasObject,
                                 l: c_short);
    pub fn evas_object_layer_get(obj: *const EvasObject)
     -> c_short;
    pub fn evas_object_below_get(obj: *const EvasObject) -> *mut EvasObject;
    pub fn evas_object_above_get(obj: *const EvasObject) -> *mut EvasObject;
    pub fn evas_object_stack_below(obj: *mut EvasObject,
                                   below: *mut EvasObject);
    pub fn evas_object_raise(obj: *mut EvasObject);
    pub fn evas_object_stack_above(obj: *mut EvasObject,
                                   above: *mut EvasObject);
    pub fn evas_object_lower(obj: *mut EvasObject);
    pub fn evas_object_evas_get(obj: *const EvasCommonInterface)
     -> *mut EvasCommonInterface;
    pub fn evas_object_size_hint_max_set(obj: *mut EvasObject, w: EvasCoord,
                                         h: EvasCoord);
    pub fn evas_object_size_hint_max_get(obj: *const EvasObject,
                                         w: *mut EvasCoord,
                                         h: *mut EvasCoord);
    pub fn evas_object_size_hint_request_set(obj: *mut EvasObject,
                                             w: EvasCoord, h: EvasCoord);
    pub fn evas_object_size_hint_request_get(obj: *const EvasObject,
                                             w: *mut EvasCoord,
                                             h: *mut EvasCoord);
    pub fn evas_object_type_get(obj: *const EvasObject)
     -> *const c_char;
    pub fn evas_object_size_hint_min_set(obj: *mut EvasObject, w: EvasCoord,
                                         h: EvasCoord);
    pub fn evas_object_size_hint_min_get(obj: *const EvasObject,
                                         w: *mut EvasCoord,
                                         h: *mut EvasCoord);
    pub fn evas_object_pointer_mode_set(obj: *mut EvasObject,
                                        pointer_mode:
                                            EvasObjectPointerMode);
    pub fn evas_object_pointer_mode_get(obj: *const EvasObject)
     -> EvasObjectPointerMode;
    pub fn evas_object_render_op_set(obj: *mut EvasObject,
                                     render_op: EvasRenderOp);
    pub fn evas_object_render_op_get(obj: *const EvasObject)
     -> EvasRenderOp;
    pub fn evas_object_freeze_events_set(obj: *mut EvasObject,
                                         freeze: EinaBool);
    pub fn evas_object_freeze_events_get(obj: *const EvasObject)
     -> EinaBool;
    pub fn evas_object_map_set(obj: *mut EvasObject, map: *const EvasMap);
    pub fn evas_object_map_get(obj: *const EvasObject) -> *const EvasMap;
    pub fn evas_object_size_hint_aspect_set(obj: *mut EvasObject,
                                            aspect: EvasAspectControl,
                                            w: EvasCoord, h: EvasCoord);
    pub fn evas_object_size_hint_aspect_get(obj: *const EvasObject,
                                            aspect: *mut EvasAspectControl,
                                            w: *mut EvasCoord,
                                            h: *mut EvasCoord);
    pub fn evas_object_clip_set(obj: *mut EvasObject,
                                clip: *mut EvasObject);
    pub fn evas_object_clip_get(obj: *const EvasObject) -> *mut EvasObject;
    pub fn evas_object_size_hint_padding_set(obj: *mut EvasObject,
                                             l: EvasCoord, r: EvasCoord,
                                             t: EvasCoord, b: EvasCoord);
    pub fn evas_object_size_hint_padding_get(obj: *const EvasObject,
                                             l: *mut EvasCoord,
                                             r: *mut EvasCoord,
                                             t: *mut EvasCoord,
                                             b: *mut EvasCoord);
    pub fn evas_object_repeat_events_set(obj: *mut EvasObject,
                                         repeat: EinaBool);
    pub fn evas_object_repeat_events_get(obj: *const EvasObject)
     -> EinaBool;
    pub fn evas_object_size_hint_weight_set(obj: *mut EvasObject,
                                            x: c_double,
                                            y: c_double);
    pub fn evas_object_size_hint_weight_get(obj: *const EvasObject,
                                            x: *mut c_double,
                                            y: *mut c_double);
    pub fn evas_object_name_set(obj: *mut EvasObject,
                                name: *const c_char);
    pub fn evas_object_name_get(obj: *const EvasObject)
     -> *const c_char;
    pub fn evas_object_scale_set(obj: *mut EvasObject,
                                 scale: c_double);
    pub fn evas_object_scale_get(obj: *const EvasObject)
     -> c_double;
    pub fn evas_object_static_clip_set(obj: *mut EvasObject,
                                       is_static_clip: EinaBool);
    pub fn evas_object_static_clip_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_focus_set(obj: *mut EvasObject, focus: EinaBool);
    pub fn evas_object_focus_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_is_frame_object_set(obj: *mut EvasObject,
                                           is_frame: EinaBool);
    pub fn evas_object_is_frame_object_get(obj: *const EvasObject)
     -> EinaBool;
    pub fn evas_object_map_enable_set(obj: *mut EvasObject,
                                      enabled: EinaBool);
    pub fn evas_object_map_enable_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_precise_is_inside_set(obj: *mut EvasObject,
                                             precise: EinaBool);
    pub fn evas_object_precise_is_inside_get(obj: *const EvasObject)
     -> EinaBool;
    pub fn evas_object_size_hint_align_set(obj: *mut EvasObject,
                                           x: c_double,
                                           y: c_double);
    pub fn evas_object_size_hint_align_get(obj: *const EvasObject,
                                           x: *mut c_double,
                                           y: *mut c_double);
    pub fn evas_object_propagate_events_set(obj: *mut EvasObject,
                                            propagate: EinaBool);
    pub fn evas_object_propagate_events_get(obj: *const EvasObject)
     -> EinaBool;
    pub fn evas_object_pass_events_set(obj: *mut EvasObject,
                                       pass: EinaBool);
    pub fn evas_object_pass_events_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_anti_alias_set(obj: *mut EvasObject,
                                      anti_alias: EinaBool);
    pub fn evas_object_anti_alias_get(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_smart_data_get(obj: *const EvasObject)
     -> *mut c_void;
    pub fn evas_object_smart_clipped_clipper_get(obj: *const EvasObject)
     -> *mut EvasObject;
    pub fn evas_object_clipees_get(obj: *const EvasObject)
     -> *const EinaList;
    pub fn evas_object_smart_parent_get(obj: *const EvasObject)
     -> *mut EvasObject;
    pub fn evas_object_size_hint_display_mode_set(obj: *mut EvasObject,
                                                  dispmode:
                                                      EvasDisplayMode);
    pub fn evas_object_size_hint_display_mode_get(obj: *const EvasObject)
     -> EvasDisplayMode;
    pub fn evas_object_clipees_has(obj: *const EvasObject) -> EinaBool;
    pub fn evas_object_key_grab(obj: *mut EvasObject,
                                keyname: *const c_char,
                                modifiers: EvasModifierMask,
                                not_modifiers: EvasModifierMask,
                                exclusive: EinaBool) -> EinaBool;
    pub fn evas_object_smart_type_check(obj: *const EvasObject,
                                        _type: *const c_char)
     -> EinaBool;
    pub fn evas_object_name_child_find(obj: *const EvasObject,
                                       name: *const c_char,
                                       recurse: c_int)
     -> *mut EvasObject;
    pub fn evas_object_key_ungrab(obj: *mut EvasObject,
                                  keyname: *const c_char,
                                  modifiers: EvasModifierMask,
                                  not_modifiers: EvasModifierMask);
    pub fn evas_object_clip_unset(obj: *mut EvasObject);
    pub fn evas_object_smart_move_children_relative(obj: *mut EvasObject,
                                                    dx: EvasCoord,
                                                    dy: EvasCoord);
    pub fn evas_object_smart_type_check_ptr(obj: *const EvasObject,
                                            _type:
                                                *const c_char)
     -> EinaBool;
    pub fn evas_object_event_callback_add(obj: *mut EvasObject,
                                          _type: EvasCallbackType,
                                          func: EvasObjectEventCb,
                                          data:
                                              *const c_void);
    pub fn evas_object_event_callback_priority_add(obj: *mut EvasObject,
                                                   _type: EvasCallbackType,
                                                   priority:
                                                       EvasCallbackPriority,
                                                   func: EvasObjectEventCb,
                                                   data:
                                                       *const c_void);
    pub fn evas_object_event_callback_del(obj: *mut EvasObject,
                                          _type: EvasCallbackType,
                                          func: EvasObjectEventCb)
     -> *mut c_void;
    pub fn evas_object_event_callback_del_full(obj: *mut EvasObject,
                                               _type: EvasCallbackType,
                                               func: EvasObjectEventCb,
                                               data:
                                                   *const c_void)
     -> *mut c_void;
    pub fn evas_object_data_set(obj: *mut EvasObject,
                                key: *const c_char,
                                data: *const c_void);
    pub fn evas_object_data_get(obj: *const EvasObject,
                                key: *const c_char)
     -> *mut c_void;
    pub fn evas_object_data_del(obj: *mut EvasObject,
                                key: *const c_char)
     -> *mut c_void;
    pub fn evas_object_top_at_pointer_get(e: *const Evas) -> *mut EvasObject;
    pub fn evas_object_intercept_show_callback_add(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptShowCb,
                                                   data:
                                                       *const c_void);
    pub fn evas_object_intercept_show_callback_del(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptShowCb)
     -> *mut c_void;
    pub fn evas_object_intercept_hide_callback_add(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptHideCb,
                                                   data:
                                                       *const c_void);
    pub fn evas_object_intercept_hide_callback_del(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptHideCb)
     -> *mut c_void;
    pub fn evas_object_intercept_move_callback_add(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptMoveCb,
                                                   data:
                                                       *const c_void);
    pub fn evas_object_intercept_move_callback_del(obj: *mut EvasObject,
                                                   func:
                                                       EvasObjectInterceptMoveCb)
     -> *mut c_void;
    pub fn evas_object_intercept_resize_callback_add(obj: *mut EvasObject,
                                                     func:
                                                         EvasObjectInterceptResizeCb,
                                                     data:
                                                         *const c_void);
    pub fn evas_object_intercept_resize_callback_del(obj: *mut EvasObject,
                                                     func:
                                                         EvasObjectInterceptResizeCb)
     -> *mut c_void;
    pub fn evas_object_intercept_raise_callback_add(obj: *mut EvasObject,
                                                    func:
                                                        EvasObjectInterceptRaiseCb,
                                                    data:
                                                        *const c_void);
    pub fn evas_object_intercept_raise_callback_del(obj: *mut EvasObject,
                                                    func:
                                                        EvasObjectInterceptRaiseCb)
     -> *mut c_void;
    pub fn evas_object_intercept_lower_callback_add(obj: *mut EvasObject,
                                                    func:
                                                        EvasObjectInterceptLowerCb,
                                                    data:
                                                        *const c_void);
    pub fn evas_object_intercept_lower_callback_del(obj: *mut EvasObject,
                                                    func:
                                                        EvasObjectInterceptLowerCb)
     -> *mut c_void;
    pub fn evas_object_intercept_stack_above_callback_add(obj:
                                                              *mut EvasObject,
                                                          func:
                                                              EvasObjectInterceptStackAboveCb,
                                                          data:
                                                              *const c_void);
    pub fn evas_object_intercept_stack_above_callback_del(obj:
                                                              *mut EvasObject,
                                                          func:
                                                              EvasObjectInterceptStackAboveCb)
     -> *mut c_void;
    pub fn evas_object_intercept_stack_below_callback_add(obj:
                                                              *mut EvasObject,
                                                          func:
                                                              EvasObjectInterceptStackBelowCb,
                                                          data:
                                                              *const c_void);
    pub fn evas_object_intercept_stack_below_callback_del(obj:
                                                              *mut EvasObject,
                                                          func:
                                                              EvasObjectInterceptStackBelowCb)
     -> *mut c_void;
    pub fn evas_object_intercept_layer_set_callback_add(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptLayerSetCb,
                                                        data:
                                                            *const c_void);
    pub fn evas_object_intercept_layer_set_callback_del(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptLayerSetCb)
     -> *mut c_void;
    pub fn evas_object_intercept_color_set_callback_add(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptColorSetCb,
                                                        data:
                                                            *const c_void);
    pub fn evas_object_intercept_color_set_callback_del(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptColorSetCb)
     -> *mut c_void;
    pub fn evas_object_intercept_clip_set_callback_add(obj: *mut EvasObject,
                                                       func:
                                                           EvasObjectInterceptClipSetCb,
                                                       data:
                                                           *const c_void);
    pub fn evas_object_intercept_clip_set_callback_del(obj: *mut EvasObject,
                                                       func:
                                                           EvasObjectInterceptClipSetCb)
     -> *mut c_void;
    pub fn evas_object_intercept_clip_unset_callback_add(obj:
                                                             *mut EvasObject,
                                                         func:
                                                             EvasObjectInterceptClipUnsetCb,
                                                         data:
                                                             *const c_void);
    pub fn evas_object_intercept_clip_unset_callback_del(obj:
                                                             *mut EvasObject,
                                                         func:
                                                             EvasObjectInterceptClipUnsetCb)
     -> *mut c_void;
    pub fn evas_object_intercept_focus_set_callback_add(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptFocusSetCb,
                                                        data:
                                                            *const c_void);
    pub fn evas_object_intercept_focus_set_callback_del(obj: *mut EvasObject,
                                                        func:
                                                            EvasObjectInterceptFocusSetCb)
     -> *mut c_void;
    pub fn evas_object_rectangle_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_image_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_image_filled_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_image_memfile_set(obj: *mut EvasObject,
                                         data: *mut c_void,
                                         size: c_int,
                                         format: *mut c_char,
                                         key: *mut c_char);
    pub fn evas_object_image_native_surface_set(obj: *mut EvasObject,
                                                surf:
                                                    *mut EvasNativeSurface);
    pub fn evas_object_image_preload(obj: *mut EvasObject,
                                     cancel: EinaBool);
    pub fn evas_object_image_source_unset(obj: *mut EvasObject) -> EinaBool;
    pub fn evas_object_image_alpha_mask_set(obj: *mut EvasObject,
                                            ismask: EinaBool);
    pub fn evas_object_image_file_set(obj: *mut Eo,
                                      file: *const c_char,
                                      key: *const c_char);
    pub fn evas_object_image_file_get(obj: *const Eo,
                                      file:
                                          *mut *const c_char,
                                      key:
                                          *mut *const c_char);
    pub fn evas_object_image_mmap_set(obj: *mut Eo, f: *const EinaFile,
                                      key: *const c_char);
    pub fn evas_object_image_mmap_get(obj: *const Eo,
                                      f: *mut *const EinaFile,
                                      key:
                                          *mut *const c_char);
    pub fn evas_object_image_save(obj: *const Eo,
                                  file: *const c_char,
                                  key: *const c_char,
                                  flags: *const c_char)
     -> EinaBool;
    pub fn evas_object_image_animated_get(obj: *const Eo) -> EinaBool;
    pub fn evas_object_image_load_size_set(obj: *mut Eo,
                                           w: c_int,
                                           h: c_int);
    pub fn evas_object_image_load_size_get(obj: *const Eo,
                                           w: *mut c_int,
                                           h: *mut c_int);
    pub fn evas_object_image_smooth_scale_set(obj: *mut Eo,
                                              smooth_scale: EinaBool);
    pub fn evas_object_image_smooth_scale_get(obj: *const Eo) -> EinaBool;
    pub fn evas_object_image_fill_spread_set(obj: *mut EvasObject,
                                             spread: EvasFillSpread);
    pub fn evas_object_image_fill_spread_get(obj: *const EvasObject)
     -> EvasFillSpread;
    pub fn evas_object_image_fill_set(obj: *mut EvasObject, x: EvasCoord,
                                      y: EvasCoord, w: EvasCoord,
                                      h: EvasCoord);
    pub fn evas_object_image_fill_get(obj: *const EvasObject,
                                      x: *mut EvasCoord, y: *mut EvasCoord,
                                      w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_object_image_size_set(obj: *mut EvasObject,
                                      w: c_int,
                                      h: c_int);
    pub fn evas_object_image_size_get(obj: *const EvasObject,
                                      w: *mut c_int,
                                      h: *mut c_int);
    pub fn evas_object_image_data_convert(obj: *mut EvasObject,
                                          to_cspace: EvasColorspace)
     -> *mut c_void;
    pub fn evas_object_image_pixels_import(obj: *mut EvasObject,
                                           pixels:
                                               *mut EvasPixelImportSource)
     -> EinaBool;
    pub fn evas_object_image_reload(obj: *mut EvasObject);
    pub fn evas_object_image_load_dpi_set(obj: *mut EvasImage,
                                          dpi: c_double);
    pub fn evas_object_image_load_dpi_get(obj: *const EvasImage)
     -> c_double;
    pub fn evas_object_image_source_clip_set(obj: *mut EvasImage,
                                             source_clip: EinaBool);
    pub fn evas_object_image_source_clip_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_source_set(obj: *mut EvasImage,
                                        src: *mut EvasObject) -> EinaBool;
    pub fn evas_object_image_source_get(obj: *const EvasImage)
     -> *mut EvasObject;
    pub fn evas_object_image_filled_set(obj: *mut EvasImage,
                                        filled: EinaBool);
    pub fn evas_object_image_filled_get(obj: *const EvasImage) -> EinaBool;
    pub fn evas_object_image_content_hint_set(obj: *mut EvasImage,
                                              hint: EvasImageContentHint);
    pub fn evas_object_image_content_hint_get(obj: *const EvasImage)
     -> EvasImageContentHint;
    pub fn evas_object_image_load_region_set(obj: *mut EvasImage,
                                             x: c_int,
                                             y: c_int,
                                             w: c_int,
                                             h: c_int);
    pub fn evas_object_image_load_region_get(obj: *const EvasImage,
                                             x: *mut c_int,
                                             y: *mut c_int,
                                             w: *mut c_int,
                                             h: *mut c_int);
    pub fn evas_object_image_alpha_set(obj: *mut EvasImage,
                                       alpha: EinaBool);
    pub fn evas_object_image_alpha_get(obj: *const EvasImage) -> EinaBool;
    pub fn evas_object_image_border_set(obj: *mut EvasImage,
                                        l: c_int,
                                        r: c_int,
                                        t: c_int,
                                        b: c_int);
    pub fn evas_object_image_border_get(obj: *const EvasImage,
                                        l: *mut c_int,
                                        r: *mut c_int,
                                        t: *mut c_int,
                                        b: *mut c_int);
    pub fn evas_object_image_border_scale_set(obj: *mut EvasImage,
                                              scale:
                                                  c_double);
    pub fn evas_object_image_border_scale_get(obj: *const EvasImage)
     -> c_double;
    pub fn evas_object_image_pixels_dirty_set(obj: *mut EvasImage,
                                              dirty: EinaBool);
    pub fn evas_object_image_pixels_dirty_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_video_surface_set(obj: *mut EvasImage,
                                               surf: *mut EvasVideoSurface);
    pub fn evas_object_image_video_surface_get(obj: *const EvasImage)
     -> *const EvasVideoSurface;
    pub fn evas_object_image_video_surface_caps_set(obj: *mut EvasImage,
                                                    caps:
                                                        c_uint);
    pub fn evas_object_image_video_surface_caps_get(obj: *const EvasImage)
     -> c_uint;
    pub fn evas_object_image_load_orientation_set(obj: *mut EvasImage,
                                                  enable: EinaBool);
    pub fn evas_object_image_load_orientation_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_border_center_fill_set(obj: *mut EvasImage,
                                                    fill:
                                                        EvasBorderFillMode);
    pub fn evas_object_image_border_center_fill_get(obj: *const EvasImage)
     -> EvasBorderFillMode;
    pub fn evas_object_image_source_visible_set(obj: *mut EvasImage,
                                                visible: EinaBool);
    pub fn evas_object_image_source_visible_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_native_surface_get(obj: *const EvasImage)
     -> *mut EvasNativeSurface;
    pub fn evas_object_image_load_scale_down_set(obj: *mut EvasImage,
                                                 scale_down:
                                                     c_int);
    pub fn evas_object_image_load_scale_down_get(obj: *const EvasImage)
     -> c_int;
    pub fn evas_object_image_scale_hint_set(obj: *mut EvasImage,
                                            hint: EvasImageScaleHint);
    pub fn evas_object_image_scale_hint_get(obj: *const EvasImage)
     -> EvasImageScaleHint;
    pub fn evas_object_image_source_events_set(obj: *mut EvasImage,
                                               source: EinaBool);
    pub fn evas_object_image_source_events_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_colorspace_set(obj: *mut EvasImage,
                                            cspace: EvasColorspace);
    pub fn evas_object_image_colorspace_get(obj: *const EvasImage)
     -> EvasColorspace;
    pub fn evas_object_image_pixels_get_callback_set(obj: *mut EvasImage,
                                                     func:
                                                         EvasObjectImagePixelsGetCb,
                                                     data:
                                                         *mut c_void);
    pub fn evas_object_image_data_copy_set(obj: *mut EvasImage,
                                           data: *mut c_void);
    pub fn evas_object_image_animated_frame_set(obj: *mut EvasImage,
                                                frame_index:
                                                    c_int);
    pub fn evas_object_image_region_support_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_load_error_get(obj: *const EvasImage)
     -> EvasLoadError;
    pub fn evas_object_image_animated_frame_count_get(obj: *const EvasImage)
     -> c_int;
    pub fn evas_object_image_stride_get(obj: *const EvasImage)
     -> c_int;
    pub fn evas_object_image_animated_loop_type_get(obj: *const EvasImage)
     -> EvasImageAnimatedLoopHint;
    pub fn evas_object_image_animated_loop_count_get(obj: *const EvasImage)
     -> c_int;
    pub fn evas_object_image_orient_set(obj: *mut EvasImage,
                                        orient: EvasImageOrient);
    pub fn evas_object_image_orient_get(obj: *const EvasImage)
     -> EvasImageOrient;
    pub fn evas_object_image_snapshot_set(obj: *mut EvasImage, s: EinaBool);
    pub fn evas_object_image_snapshot_get(obj: *const EvasImage)
     -> EinaBool;
    pub fn evas_object_image_data_update_add(obj: *mut EvasImage,
                                             x: c_int,
                                             y: c_int,
                                             w: c_int,
                                             h: c_int);
    pub fn evas_object_image_animated_frame_duration_get(obj:
                                                             *const EvasImage,
                                                         start_frame:
                                                             c_int,
                                                         frame_num:
                                                             c_int)
     -> c_double;
    pub fn evas_object_image_data_set(obj: *mut EvasImage,
                                      data: *mut c_void);
    pub fn evas_object_image_data_get(obj: *const EvasImage,
                                      for_writing: EinaBool)
     -> *mut c_void;
    pub fn evas_object_text_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_text_text_set(obj: *mut Eo,
                                     text: *const c_char);
    pub fn evas_object_text_text_get(obj: *const Eo)
     -> *const c_char;
    pub fn evas_object_text_shadow_color_set(obj: *mut EvasText,
                                             r: c_int,
                                             g: c_int,
                                             b: c_int,
                                             a: c_int);
    pub fn evas_object_text_shadow_color_get(obj: *const EvasText,
                                             r: *mut c_int,
                                             g: *mut c_int,
                                             b: *mut c_int,
                                             a: *mut c_int);
    pub fn evas_object_text_ellipsis_set(obj: *mut EvasText,
                                         ellipsis: c_double);
    pub fn evas_object_text_ellipsis_get(obj: *const EvasText)
     -> c_double;
    pub fn evas_object_text_bidi_delimiters_set(obj: *mut EvasText,
                                                delim:
                                                    *const c_char);
    pub fn evas_object_text_bidi_delimiters_get(obj: *const EvasText)
     -> *const c_char;
    pub fn evas_object_text_outline_color_set(obj: *mut EvasText,
                                              r: c_int,
                                              g: c_int,
                                              b: c_int,
                                              a: c_int);
    pub fn evas_object_text_outline_color_get(obj: *const EvasText,
                                              r: *mut c_int,
                                              g: *mut c_int,
                                              b: *mut c_int,
                                              a: *mut c_int);
    pub fn evas_object_text_glow2_color_set(obj: *mut EvasText,
                                            r: c_int,
                                            g: c_int,
                                            b: c_int,
                                            a: c_int);
    pub fn evas_object_text_glow2_color_get(obj: *const EvasText,
                                            r: *mut c_int,
                                            g: *mut c_int,
                                            b: *mut c_int,
                                            a: *mut c_int);
    pub fn evas_object_text_style_set(obj: *mut EvasText,
                                      style: EvasTextStyleType);
    pub fn evas_object_text_style_get(obj: *const EvasText)
     -> EvasTextStyleType;
    pub fn evas_object_text_glow_color_set(obj: *mut EvasText,
                                           r: c_int,
                                           g: c_int,
                                           b: c_int,
                                           a: c_int);
    pub fn evas_object_text_glow_color_get(obj: *const EvasText,
                                           r: *mut c_int,
                                           g: *mut c_int,
                                           b: *mut c_int,
                                           a: *mut c_int);
    pub fn evas_object_text_max_descent_get(obj: *const EvasText)
     -> EvasCoord;
    pub fn evas_object_text_style_pad_get(obj: *const EvasText,
                                          l: *mut c_int,
                                          r: *mut c_int,
                                          t: *mut c_int,
                                          b: *mut c_int);
    pub fn evas_object_text_direction_get(obj: *const EvasText)
     -> EvasBidiDirection;
    pub fn evas_object_text_ascent_get(obj: *const EvasText) -> EvasCoord;
    pub fn evas_object_text_horiz_advance_get(obj: *const EvasText)
     -> EvasCoord;
    pub fn evas_object_text_inset_get(obj: *const EvasText) -> EvasCoord;
    pub fn evas_object_text_max_ascent_get(obj: *const EvasText)
     -> EvasCoord;
    pub fn evas_object_text_vert_advance_get(obj: *const EvasText)
     -> EvasCoord;
    pub fn evas_object_text_descent_get(obj: *const EvasText) -> EvasCoord;
    pub fn evas_object_text_last_up_to_pos(obj: *const EvasText,
                                           x: EvasCoord, y: EvasCoord)
     -> c_int;
    pub fn evas_object_text_char_coords_get(obj: *const EvasText,
                                            x: EvasCoord, y: EvasCoord,
                                            cx: *mut EvasCoord,
                                            cy: *mut EvasCoord,
                                            cw: *mut EvasCoord,
                                            ch: *mut EvasCoord)
     -> c_int;
    pub fn evas_object_text_char_pos_get(obj: *const EvasText,
                                         pos: c_int,
                                         cx: *mut EvasCoord,
                                         cy: *mut EvasCoord,
                                         cw: *mut EvasCoord,
                                         ch: *mut EvasCoord) -> EinaBool;
    pub fn evas_object_text_font_source_set(obj: *mut Eo,
                                            font_source:
                                                *const c_char);
    pub fn evas_object_text_font_source_get(obj: *const Eo)
     -> *const c_char;
    pub fn evas_object_text_font_set(obj: *mut Eo,
                                     font: *const c_char,
                                     size: EvasFontSize);
    pub fn evas_object_text_font_get(obj: *const Eo,
                                     font: *mut *const c_char,
                                     size: *mut EvasFontSize);
    pub fn evas_object_textblock_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_textblock_text_markup_to_utf8(obj: *const EvasObject,
                                              text:
                                                  *const c_char)
     -> *mut c_char;
    pub fn evas_textblock_text_utf8_to_markup(obj: *const EvasObject,
                                              text:
                                                  *const c_char)
     -> *mut c_char;
    pub fn evas_object_textblock_clear(obj: *mut EvasObject);
    pub fn evas_object_textblock_text_markup_set(obj: *mut EvasTextblock,
                                                 text:
                                                     *const c_char);
    pub fn evas_object_textblock_text_markup_get(obj: *const EvasTextblock)
     -> *const c_char;
    pub fn evas_object_textblock_valign_set(obj: *mut EvasTextblock,
                                            align: c_double);
    pub fn evas_object_textblock_valign_get(obj: *const EvasTextblock)
     -> c_double;
    pub fn evas_object_textblock_bidi_delimiters_set(obj: *mut EvasTextblock,
                                                     delim:
                                                         *const c_char);
    pub fn evas_object_textblock_bidi_delimiters_get(obj:
                                                         *const EvasTextblock)
     -> *const c_char;
    pub fn evas_object_textblock_replace_char_set(obj: *mut EvasTextblock,
                                                  ch:
                                                      *const c_char);
    pub fn evas_object_textblock_legacy_newline_set(obj: *mut EvasTextblock,
                                                    mode: EinaBool);
    pub fn evas_object_textblock_legacy_newline_get(obj:
                                                        *const EvasTextblock)
     -> EinaBool;
    pub fn evas_object_textblock_style_set(obj: *mut EvasTextblock,
                                           ts: *const EvasTextblockStyle);
    pub fn evas_object_textblock_style_get(obj: *const EvasTextblock)
     -> *const EvasTextblockStyle;
    pub fn evas_textblock_node_format_first_get(obj: *const EvasTextblock)
     -> *const EvasTextblockNodeFormat;
    pub fn evas_object_textblock_size_formatted_get(obj:
                                                        *const EvasTextblock,
                                                    w: *mut EvasCoord,
                                                    h: *mut EvasCoord);
    pub fn evas_textblock_node_format_last_get(obj: *const EvasTextblock)
     -> *const EvasTextblockNodeFormat;
    pub fn evas_object_textblock_cursor_get(obj: *const EvasTextblock)
     -> *mut EvasTextblockCursor;
    pub fn evas_object_textblock_size_native_get(obj: *const EvasTextblock,
                                                 w: *mut EvasCoord,
                                                 h: *mut EvasCoord);
    pub fn evas_object_textblock_style_insets_get(obj: *const EvasTextblock,
                                                  l: *mut EvasCoord,
                                                  r: *mut EvasCoord,
                                                  t: *mut EvasCoord,
                                                  b: *mut EvasCoord);
    pub fn evas_object_textblock_line_number_geometry_get(obj:
                                                              *const EvasTextblock,
                                                          line:
                                                              c_int,
                                                          cx: *mut EvasCoord,
                                                          cy: *mut EvasCoord,
                                                          cw: *mut EvasCoord,
                                                          ch: *mut EvasCoord)
     -> EinaBool;
    pub fn evas_object_textblock_replace_char_get(obj: *mut EvasTextblock)
     -> *const c_char;
    pub fn evas_object_textblock_style_user_pop(obj: *mut EvasTextblock);
    pub fn evas_object_textblock_cursor_new(obj: *const EvasTextblock)
     -> *mut EvasTextblockCursor;
    pub fn evas_textblock_node_format_list_get(obj: *const EvasTextblock,
                                               anchor:
                                                   *const c_char)
     -> *const EinaList;
    pub fn evas_object_textblock_style_user_peek(obj: *const EvasTextblock)
     -> *const EvasTextblockStyle;
    pub fn evas_textblock_node_format_remove_pair(obj: *mut EvasTextblock,
                                                  n:
                                                      *mut EvasTextblockNodeFormat);
    pub fn evas_object_textblock_style_user_push(obj: *mut EvasTextblock,
                                                 ts:
                                                     *mut EvasTextblockStyle);
    pub fn evas_object_textblock_obstacle_add(obj: *mut EvasTextblock,
                                              eo_obs: *mut EvasObject)
     -> EinaBool;
    pub fn evas_object_textblock_obstacle_del(obj: *mut EvasTextblock,
                                              eo_obs: *mut EvasObject)
     -> EinaBool;
    pub fn evas_object_textblock_obstacles_update(obj: *mut EvasTextblock);
    pub fn evas_object_textgrid_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_textgrid_supported_font_styles_set(obj:
                                                              *mut EvasTextgrid,
                                                          styles:
                                                              EvasTextgridFontStyle);
    pub fn evas_object_textgrid_supported_font_styles_get(obj:
                                                              *const EvasTextgrid)
     -> EvasTextgridFontStyle;
    pub fn evas_object_textgrid_size_set(obj: *mut EvasTextgrid,
                                         w: c_int,
                                         h: c_int);
    pub fn evas_object_textgrid_size_get(obj: *const EvasTextgrid,
                                         w: *mut c_int,
                                         h: *mut c_int);
    pub fn evas_object_textgrid_cell_size_get(obj: *const EvasTextgrid,
                                              width:
                                                  *mut c_int,
                                              height:
                                                  *mut c_int);
    pub fn evas_object_textgrid_update_add(obj: *mut EvasTextgrid,
                                           x: c_int,
                                           y: c_int,
                                           w: c_int,
                                           h: c_int);
    pub fn evas_object_textgrid_cellrow_set(obj: *mut EvasTextgrid,
                                            y: c_int,
                                            row: *const EvasTextgridCell);
    pub fn evas_object_textgrid_cellrow_get(obj: *const EvasTextgrid,
                                            y: c_int)
     -> *mut EvasTextgridCell;
    pub fn evas_object_textgrid_palette_set(obj: *mut EvasTextgrid,
                                            pal: EvasTextgridPalette,
                                            idx: c_int,
                                            r: c_int,
                                            g: c_int,
                                            b: c_int,
                                            a: c_int);
    pub fn evas_object_textgrid_palette_get(obj: *const EvasTextgrid,
                                            pal: EvasTextgridPalette,
                                            idx: c_int,
                                            r: *mut c_int,
                                            g: *mut c_int,
                                            b: *mut c_int,
                                            a: *mut c_int);
    pub fn evas_object_textgrid_font_source_set(obj: *mut Eo,
                                                font_source:
                                                    *const c_char);
    pub fn evas_object_textgrid_font_source_get(obj: *const Eo)
     -> *const c_char;
    pub fn evas_object_textgrid_font_set(obj: *mut Eo,
                                         font_name:
                                             *const c_char,
                                         font_size: EvasFontSize);
    pub fn evas_object_textgrid_font_get(obj: *const Eo,
                                         font_name:
                                             *mut *const c_char,
                                         font_size: *mut EvasFontSize);
    pub fn evas_object_line_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_line_xy_set(obj: *mut EvasLine, x1: EvasCoord,
                                   y1: EvasCoord, x2: EvasCoord,
                                   y2: EvasCoord);
    pub fn evas_object_line_xy_get(obj: *const EvasLine, x1: *mut EvasCoord,
                                   y1: *mut EvasCoord, x2: *mut EvasCoord,
                                   y2: *mut EvasCoord);
    pub fn evas_object_polygon_add(e: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_polygon_point_add(obj: *mut EvasPolygon,
                                         x: EvasCoord, y: EvasCoord);
    pub fn evas_object_polygon_points_clear(obj: *mut EvasPolygon);
    pub fn evas_object_smart_add(e: *mut Evas, s: *mut EvasSmart)
     -> *mut EvasObject;
    pub fn evas_object_smart_member_add(obj: *mut EvasObject,
                                        smart_obj: *mut EvasObject);
    pub fn evas_object_smart_member_del(obj: *mut EvasObject);
    pub fn evas_object_smart_callback_add(obj: *mut EvasObject,
                                          event:
                                              *const c_char,
                                          func: EvasSmartCb,
                                          data:
                                              *const c_void);
    pub fn evas_object_smart_callback_priority_add(obj: *mut EvasObject,
                                                   event:
                                                       *const c_char,
                                                   priority:
                                                       EvasCallbackPriority,
                                                   func: EvasSmartCb,
                                                   data:
                                                       *const c_void);
    pub fn evas_object_smart_callback_del(obj: *mut EvasObject,
                                          event:
                                              *const c_char,
                                          func: EvasSmartCb)
     -> *mut c_void;
    pub fn evas_object_smart_callback_del_full(obj: *mut EvasObject,
                                               event:
                                                   *const c_char,
                                               func: EvasSmartCb,
                                               data:
                                                   *const c_void)
     -> *mut c_void;
    pub fn evas_object_smart_callback_call(obj: *mut EvasObject,
                                           event:
                                               *const c_char,
                                           event_info:
                                               *mut c_void);
    pub fn evas_object_smart_interface_get(obj: *const EvasObject,
                                           name:
                                               *const c_char)
     -> *const c_void;
    pub fn evas_object_smart_interface_data_get(obj: *const EvasObject,
                                                iface:
                                                    *const EvasSmartInterface)
     -> *mut c_void;
    pub fn evas_object_smart_need_recalculate_set(obj: *mut EvasObjectSmart,
                                                  value: EinaBool);
    pub fn evas_object_smart_need_recalculate_get(obj:
                                                      *const EvasObjectSmart)
     -> EinaBool;
    pub fn evas_object_smart_data_set(obj: *mut EvasObjectSmart,
                                      data: *mut c_void);
    pub fn evas_object_smart_members_get(obj: *const EvasObjectSmart)
     -> *mut EinaList;
    pub fn evas_object_smart_smart_get(obj: *const EvasObjectSmart)
     -> *mut EvasSmart;
    pub fn evas_object_smart_callbacks_descriptions_set(obj:
                                                            *mut EvasObjectSmart,
                                                        descriptions:
                                                            *const EvasSmartCbDescription)
     -> EinaBool;
    pub fn evas_object_smart_callbacks_descriptions_get(obj:
                                                            *const EvasObjectSmart,
                                                        class_descriptions:
                                                            *mut *mut *const EvasSmartCbDescription,
                                                        class_count:
                                                            *mut c_uint,
                                                        instance_descriptions:
                                                            *mut *mut *const EvasSmartCbDescription,
                                                        instance_count:
                                                            *mut c_uint);
    pub fn evas_object_smart_iterator_new(obj: *const EvasObjectSmart)
     -> *mut EinaIterator;
    pub fn evas_object_smart_callback_description_find(obj:
                                                           *const EvasObjectSmart,
                                                       name:
                                                           *const c_char,
                                                       class_description:
                                                           *mut *const EvasSmartCbDescription,
                                                       instance_description:
                                                           *mut *const EvasSmartCbDescription);
    pub fn evas_object_smart_calculate(obj: *mut EvasObjectSmart);
    pub fn evas_object_smart_changed(obj: *mut EvasObjectSmart);
    pub fn evas_object_box_add(evas: *mut Evas) -> *mut EvasObject;
/*    pub fn evas_object_box_option_property_vget(o: *const EvasObject,
                                                opt:
                                                    *mut EvasObjectBoxOption,
                                                property:
                                                    c_int,
                                                args: va_list) -> EinaBool;
    pub fn evas_object_box_option_property_vset(o: *mut EvasObject,
                                                opt:
                                                    *mut EvasObjectBoxOption,
                                                property:
                                                    c_int,
                                                args: va_list) -> EinaBool;
*/
    pub fn evas_object_box_option_property_set(o: *mut EvasObject,
                                               opt:
                                                   *mut EvasObjectBoxOption,
                                               property:
                                                   c_int, ...)
     -> EinaBool;
    pub fn evas_object_box_option_property_get(o: *const EvasObject,
                                               opt:
                                                   *mut EvasObjectBoxOption,
                                               property:
                                                   c_int, ...)
     -> EinaBool;
    pub fn evas_object_box_children_get(o: *const EvasObject)
     -> *mut EinaList;
    pub fn evas_object_box_align_set(obj: *mut EvasBox,
                                     horizontal: c_double,
                                     vertical: c_double);
    pub fn evas_object_box_align_get(obj: *const EvasBox,
                                     horizontal:
                                         *mut c_double,
                                     vertical: *mut c_double);
    pub fn evas_object_box_padding_set(obj: *mut EvasBox,
                                       horizontal: EvasCoord,
                                       vertical: EvasCoord);
    pub fn evas_object_box_padding_get(obj: *const EvasBox,
                                       horizontal: *mut EvasCoord,
                                       vertical: *mut EvasCoord);
    pub fn evas_object_box_layout_set(obj: *mut EvasBox,
                                      cb: EvasObjectBoxLayout,
                                      data: *const c_void,
                                      free_data: EinaFreeCb);
    pub fn evas_object_box_layout_horizontal(obj: *mut EvasBox,
                                             _priv: *mut EvasObjectBoxData,
                                             data:
                                                 *mut c_void);
    pub fn evas_object_box_layout_vertical(obj: *mut EvasBox,
                                           _priv: *mut EvasObjectBoxData,
                                           data: *mut c_void);
    pub fn evas_object_box_layout_homogeneous_max_size_horizontal(obj:
                                                                      *mut EvasBox,
                                                                  _priv:
                                                                      *mut EvasObjectBoxData,
                                                                  data:
                                                                      *mut c_void);
    pub fn evas_object_box_layout_flow_vertical(obj: *mut EvasBox,
                                                _priv:
                                                    *mut EvasObjectBoxData,
                                                data:
                                                    *mut c_void);
    pub fn evas_object_box_insert_after(obj: *mut EvasBox,
                                        child: *mut EvasObject,
                                        reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_object_box_remove_all(obj: *mut EvasBox, clear: EinaBool)
     -> EinaBool;
    pub fn evas_object_box_iterator_new(obj: *const EvasBox)
     -> *mut EinaIterator;
    pub fn evas_object_box_add_to(obj: *mut EvasBox) -> *mut EvasObject;
    pub fn evas_object_box_append(obj: *mut EvasBox, child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_object_box_option_property_id_get(obj: *const EvasBox,
                                                  name:
                                                      *const c_char)
     -> c_int;
    pub fn evas_object_box_prepend(obj: *mut EvasBox,
                                   child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_object_box_accessor_new(obj: *const EvasBox)
     -> *mut EinaAccessor;
    pub fn evas_object_box_remove_at(obj: *mut EvasBox,
                                     pos: c_uint)
     -> EinaBool;
    pub fn evas_object_box_insert_before(obj: *mut EvasBox,
                                         child: *mut EvasObject,
                                         reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_object_box_option_property_name_get(obj: *const EvasBox,
                                                    property:
                                                        c_int)
     -> *const c_char;
    pub fn evas_object_box_layout_homogeneous_horizontal(obj: *mut EvasBox,
                                                         _priv:
                                                             *mut EvasObjectBoxData,
                                                         data:
                                                             *mut c_void);
    pub fn evas_object_box_layout_homogeneous_max_size_vertical(obj:
                                                                    *mut EvasBox,
                                                                _priv:
                                                                    *mut EvasObjectBoxData,
                                                                data:
                                                                    *mut c_void);
    pub fn evas_object_box_insert_at(obj: *mut EvasBox,
                                     child: *mut EvasObject,
                                     pos: c_uint)
     -> *mut EvasObjectBoxOption;
    pub fn evas_object_box_remove(obj: *mut EvasBox, child: *mut EvasObject)
     -> EinaBool;
    pub fn evas_object_box_layout_stack(obj: *mut EvasBox,
                                        _priv: *mut EvasObjectBoxData,
                                        data: *mut c_void);
    pub fn evas_object_box_layout_homogeneous_vertical(obj: *mut EvasBox,
                                                       _priv:
                                                           *mut EvasObjectBoxData,
                                                       data:
                                                           *mut c_void);
    pub fn evas_object_box_layout_flow_horizontal(obj: *mut EvasBox,
                                                  _priv:
                                                      *mut EvasObjectBoxData,
                                                  data:
                                                      *mut c_void);
    pub fn evas_object_table_add(evas: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_table_child_get(obj: *const EvasTable,
                                       col: c_ushort,
                                       row: c_ushort)
     -> *mut EvasObject;
    pub fn evas_object_table_homogeneous_set(obj: *mut EvasTable,
                                             homogeneous:
                                                 EvasObjectTableHomogeneousMode);
    pub fn evas_object_table_homogeneous_get(obj: *const EvasTable)
     -> EvasObjectTableHomogeneousMode;
    pub fn evas_object_table_align_set(obj: *mut EvasTable,
                                       horizontal: c_double,
                                       vertical: c_double);
    pub fn evas_object_table_align_get(obj: *const EvasTable,
                                       horizontal:
                                           *mut c_double,
                                       vertical:
                                           *mut c_double);
    pub fn evas_object_table_padding_set(obj: *mut EvasTable,
                                         horizontal: EvasCoord,
                                         vertical: EvasCoord);
    pub fn evas_object_table_padding_get(obj: *const EvasTable,
                                         horizontal: *mut EvasCoord,
                                         vertical: *mut EvasCoord);
    pub fn evas_object_table_mirrored_set(obj: *mut EvasTable,
                                          mirrored: EinaBool);
    pub fn evas_object_table_mirrored_get(obj: *const EvasTable)
     -> EinaBool;
    pub fn evas_object_table_col_row_size_get(obj: *const EvasTable,
                                              cols:
                                                  *mut c_int,
                                              rows:
                                                  *mut c_int);
    pub fn evas_object_table_children_get(obj: *const EvasTable)
     -> *mut EinaList;
    pub fn evas_object_table_clear(obj: *mut EvasTable, clear: EinaBool);
    pub fn evas_object_table_accessor_new(obj: *const EvasTable)
     -> *mut EinaAccessor;
    pub fn evas_object_table_iterator_new(obj: *const EvasTable)
     -> *mut EinaIterator;
    pub fn evas_object_table_add_to(obj: *mut EvasTable) -> *mut EvasObject;
    pub fn evas_object_table_pack_get(obj: *const EvasTable,
                                      child: *mut EvasObject,
                                      col: *mut c_ushort,
                                      row: *mut c_ushort,
                                      colspan: *mut c_ushort,
                                      rowspan: *mut c_ushort)
     -> EinaBool;
    pub fn evas_object_table_pack(obj: *mut EvasTable,
                                  child: *mut EvasObject,
                                  col: c_ushort,
                                  row: c_ushort,
                                  colspan: c_ushort,
                                  rowspan: c_ushort)
     -> EinaBool;
    pub fn evas_object_table_unpack(obj: *mut EvasTable,
                                    child: *mut EvasObject) -> EinaBool;
    pub fn evas_object_grid_add(evas: *mut Evas) -> *mut EvasObject;
    pub fn evas_object_grid_mirrored_set(obj: *mut EvasGrid,
                                         mirrored: EinaBool);
    pub fn evas_object_grid_mirrored_get(obj: *const EvasGrid) -> EinaBool;
    pub fn evas_object_grid_size_set(obj: *mut EvasGrid,
                                     w: c_int,
                                     h: c_int);
    pub fn evas_object_grid_size_get(obj: *const EvasGrid,
                                     w: *mut c_int,
                                     h: *mut c_int);
    pub fn evas_object_grid_children_get(obj: *const EvasGrid)
     -> *mut EinaList;
    pub fn evas_object_grid_accessor_new(obj: *const EvasGrid)
     -> *mut EinaAccessor;
    pub fn evas_object_grid_clear(obj: *mut EvasGrid, clear: EinaBool);
    pub fn evas_object_grid_iterator_new(obj: *const EvasGrid)
     -> *mut EinaIterator;
    pub fn evas_object_grid_add_to(obj: *mut EvasGrid) -> *mut EvasObject;
    pub fn evas_object_grid_unpack(obj: *mut EvasGrid,
                                   child: *mut EvasObject) -> EinaBool;
    pub fn evas_object_grid_pack_get(obj: *const EvasGrid,
                                     child: *mut EvasObject,
                                     x: *mut c_int,
                                     y: *mut c_int,
                                     w: *mut c_int,
                                     h: *mut c_int)
     -> EinaBool;
    pub fn evas_object_grid_pack(obj: *mut EvasGrid, child: *mut EvasObject,
                                 x: c_int,
                                 y: c_int,
                                 w: c_int,
                                 h: c_int) -> EinaBool;
    pub fn evas_out_add(e: *mut Evas) -> *mut EvasOut;
    pub fn evas_output_del(evo: *mut EvasOut);
    pub fn evas_output_view_set(obj: *mut EvasOut, x: EvasCoord,
                                y: EvasCoord, w: EvasCoord, h: EvasCoord);
    pub fn evas_output_view_get(obj: *const EvasOut, x: *mut EvasCoord,
                                y: *mut EvasCoord, w: *mut EvasCoord,
                                h: *mut EvasCoord);
    pub fn evas_output_engine_info_set(obj: *mut EvasOut,
                                       info: *mut EvasEngineInfo)
     -> EinaBool;
    pub fn evas_output_engine_info_get(obj: *const EvasOut)
     -> *mut EvasEngineInfo;

//----------------------------------------------------------------------------------------------
// Evas Eo
//----------------------------------------------------------------------------------------------
    pub fn evas_signal_interface_interface_get() -> *const EoClass;
    pub fn evas_draggable_interface_interface_get() -> *const EoClass;
    pub fn evas_clickable_interface_interface_get() -> *const EoClass;
    pub fn evas_scrollable_interface_interface_get() -> *const EoClass;
    pub fn evas_selectable_interface_interface_get() -> *const EoClass;
    pub fn evas_zoomable_interface_interface_get() -> *const EoClass;
    pub fn evas_canvas_class_get() -> *const EoClass;
    pub fn evas_canvas_output_framespace_set(x: EvasCoord, y: EvasCoord,
                                             w: EvasCoord, h: EvasCoord);
    pub fn evas_canvas_output_framespace_get(x: *mut EvasCoord,
                                             y: *mut EvasCoord,
                                             w: *mut EvasCoord,
                                             h: *mut EvasCoord);
    pub fn evas_canvas_output_viewport_set(x: EvasCoord, y: EvasCoord,
                                           w: EvasCoord, h: EvasCoord);
    pub fn evas_canvas_output_viewport_get(x: *mut EvasCoord,
                                           y: *mut EvasCoord,
                                           w: *mut EvasCoord,
                                           h: *mut EvasCoord);
    pub fn evas_canvas_image_cache_set(size: c_int);
    pub fn evas_canvas_image_cache_get() -> c_int;
    pub fn evas_canvas_event_default_flags_set(flags: EvasEventFlags);
    pub fn evas_canvas_event_default_flags_get() -> EvasEventFlags;
    pub fn evas_canvas_output_method_set(render_method:
                                             c_int);
    pub fn evas_canvas_output_method_get() -> c_int;
    pub fn evas_canvas_font_cache_set(size: c_int);
    pub fn evas_canvas_font_cache_get() -> c_int;
    pub fn evas_canvas_output_size_set(w: c_int,
                                       h: c_int);
    pub fn evas_canvas_output_size_get(w: *mut c_int,
                                       h: *mut c_int);
    pub fn evas_canvas_data_attach_set(data: *mut c_void);
    pub fn evas_canvas_data_attach_get() -> *mut c_void;
    pub fn evas_canvas_font_hinting_set(hinting: EvasFontHintingFlags);
    pub fn evas_canvas_font_hinting_get() -> EvasFontHintingFlags;
    pub fn evas_canvas_engine_info_set(info: *mut EvasEngineInfo)
     -> EinaBool;
    pub fn evas_canvas_engine_info_get() -> *mut EvasEngineInfo;
    pub fn evas_canvas_focus_get() -> *mut EvasObject;
    pub fn evas_canvas_object_top_get() -> *mut EvasObject;
    pub fn evas_canvas_key_lock_get() -> *const EvasLock;
    pub fn evas_canvas_pointer_canvas_xy_get(x: *mut EvasCoord,
                                             y: *mut EvasCoord);
    pub fn evas_canvas_event_down_count_get() -> c_int;
    pub fn evas_canvas_smart_objects_calculate_count_get()
     -> c_int;
    pub fn evas_canvas_focus_state_get() -> EinaBool;
    pub fn evas_canvas_changed_get() -> EinaBool;
    pub fn evas_canvas_pointer_output_xy_get(x: *mut c_int,
                                             y: *mut c_int);
    pub fn evas_canvas_pointer_inside_get() -> EinaBool;
    pub fn evas_canvas_image_max_size_get(maxw: *mut c_int,
                                          maxh: *mut c_int)
     -> EinaBool;
    pub fn evas_canvas_object_bottom_get() -> *mut EvasObject;
    pub fn evas_canvas_key_modifier_get() -> *const EvasModifier;
    pub fn evas_canvas_pointer_button_down_mask_get()
     -> c_int;
    pub fn evas_canvas_tree_objects_at_xy_get(stop: *mut EvasObject,
                                              x: c_int,
                                              y: c_int)
     -> *mut EinaList;
    pub fn evas_canvas_event_feed_mouse_wheel(direction:
                                                  c_int,
                                              z: c_int,
                                              timestamp:
                                                  c_uint,
                                              data:
                                                  *const c_void);
    pub fn evas_canvas_key_lock_on(keyname: *const c_char);
    pub fn evas_canvas_event_feed_key_down(keyname:
                                               *const c_char,
                                           key: *const c_char,
                                           string:
                                               *const c_char,
                                           compose:
                                               *const c_char,
                                           timestamp: c_uint,
                                           data:
                                               *const c_void);
    pub fn evas_canvas_key_modifier_mask_get(keyname:
                                                 *const c_char)
     -> EvasModifierMask;
    pub fn evas_canvas_key_modifier_add(keyname:
                                            *const c_char);
    pub fn evas_canvas_key_modifier_off(keyname:
                                            *const c_char);
    pub fn evas_canvas_event_feed_hold(hold: c_int,
                                       timestamp: c_uint,
                                       data: *const c_void);
    pub fn evas_canvas_event_feed_mouse_move(x: c_int,
                                             y: c_int,
                                             timestamp:
                                                 c_uint,
                                             data:
                                                 *const c_void);
    pub fn evas_canvas_event_feed_key_up(keyname:
                                             *const c_char,
                                         key: *const c_char,
                                         string:
                                             *const c_char,
                                         compose:
                                             *const c_char,
                                         timestamp: c_uint,
                                         data: *const c_void);
    pub fn evas_canvas_event_feed_mouse_out(timestamp: c_uint,
                                            data:
                                                *const c_void);
    pub fn evas_canvas_event_input_multi_move(d: c_int,
                                              x: c_int,
                                              y: c_int,
                                              rad: c_double,
                                              radx: c_double,
                                              rady: c_double,
                                              pres: c_double,
                                              ang: c_double,
                                              fx: c_double,
                                              fy: c_double,
                                              timestamp:
                                                  c_uint,
                                              data:
                                                  *const c_void);
    pub fn evas_canvas_objects_at_xy_get(x: EvasCoord, y: EvasCoord,
                                         include_pass_events_objects:
                                             EinaBool,
                                         include_hidden_objects: EinaBool)
     -> *mut EinaList;
    pub fn evas_canvas_event_input_multi_up(d: c_int,
                                            x: c_int,
                                            y: c_int,
                                            rad: c_double,
                                            radx: c_double,
                                            rady: c_double,
                                            pres: c_double,
                                            ang: c_double,
                                            fx: c_double,
                                            fy: c_double,
                                            flags: EvasButtonFlags,
                                            timestamp: c_uint,
                                            data:
                                                *const c_void);
    pub fn evas_canvas_event_feed_multi_down(d: c_int,
                                             x: c_int,
                                             y: c_int,
                                             rad: c_double,
                                             radx: c_double,
                                             rady: c_double,
                                             pres: c_double,
                                             ang: c_double,
                                             fx: c_double,
                                             fy: c_double,
                                             flags: EvasButtonFlags,
                                             timestamp:
                                                 c_uint,
                                             data:
                                                 *const c_void);
    pub fn evas_canvas_render_async() -> EinaBool;
    pub fn evas_canvas_render2() -> EinaBool;
    pub fn evas_canvas_render2_updates() -> *mut EinaList;
    pub fn evas_canvas_focus_out();
    pub fn evas_canvas_event_input_mouse_move(x: c_int,
                                              y: c_int,
                                              timestamp:
                                                  c_uint,
                                              data:
                                                  *const c_void);
    pub fn evas_canvas_norender();
    pub fn evas_canvas_touch_point_list_count() -> c_uint;
    pub fn evas_canvas_event_input_multi_down(d: c_int,
                                              x: c_int,
                                              y: c_int,
                                              rad: c_double,
                                              radx: c_double,
                                              rady: c_double,
                                              pres: c_double,
                                              ang: c_double,
                                              fx: c_double,
                                              fy: c_double,
                                              flags: EvasButtonFlags,
                                              timestamp:
                                                  c_uint,
                                              data:
                                                  *const c_void);
    pub fn evas_canvas_nochange_pop();
    pub fn evas_canvas_key_lock_off(keyname: *const c_char);
    pub fn evas_canvas_nochange_push();
    pub fn evas_canvas_font_cache_flush();
    pub fn evas_canvas_font_hinting_can_hint(hinting: EvasFontHintingFlags)
     -> EinaBool;
    pub fn evas_canvas_object_top_at_xy_get(x: EvasCoord, y: EvasCoord,
                                            include_pass_events_objects:
                                                EinaBool,
                                            include_hidden_objects: EinaBool)
     -> *mut EvasObject;
    pub fn evas_canvas_key_modifier_on(keyname:
                                           *const c_char);
    pub fn evas_canvas_event_feed_mouse_up(b: c_int,
                                           flags: EvasButtonFlags,
                                           timestamp: c_uint,
                                           data:
                                               *const c_void);
    pub fn evas_canvas_event_feed_mouse_down(b: c_int,
                                             flags: EvasButtonFlags,
                                             timestamp:
                                                 c_uint,
                                             data:
                                                 *const c_void);
    pub fn evas_canvas_event_refeed_event(event_copy:
                                              *mut c_void,
                                          event_type: EvasCallbackType);
    pub fn evas_canvas_font_available_list() -> *mut EinaList;
    pub fn evas_canvas_objects_in_rectangle_get(x: EvasCoord, y: EvasCoord,
                                                w: EvasCoord, h: EvasCoord,
                                                include_pass_events_objects:
                                                    EinaBool,
                                                include_hidden_objects:
                                                    EinaBool)
     -> *mut EinaList;
    pub fn evas_canvas_object_name_find(name: *const c_char)
     -> *mut EvasObject;
    pub fn evas_canvas_font_path_append(path: *const c_char);
    pub fn evas_canvas_touch_point_list_nth_id_get(n: c_uint)
     -> c_int;
    pub fn evas_canvas_font_path_clear();
    pub fn evas_canvas_smart_objects_calculate();
    pub fn evas_canvas_touch_point_list_nth_xy_get(n: c_uint,
                                                   x: *mut EvasCoord,
                                                   y: *mut EvasCoord);
    pub fn evas_canvas_key_lock_del(keyname: *const c_char);
    pub fn evas_canvas_damage_rectangle_add(x: c_int,
                                            y: c_int,
                                            w: c_int,
                                            h: c_int);
    pub fn evas_canvas_sync();
    pub fn evas_canvas_font_path_list() -> *const EinaList;
    pub fn evas_canvas_image_cache_reload();
    pub fn evas_canvas_coord_world_x_to_screen(x: EvasCoord)
     -> c_int;
    pub fn evas_canvas_event_feed_multi_move(d: c_int,
                                             x: c_int,
                                             y: c_int,
                                             rad: c_double,
                                             radx: c_double,
                                             rady: c_double,
                                             pres: c_double,
                                             ang: c_double,
                                             fx: c_double,
                                             fy: c_double,
                                             timestamp:
                                                 c_uint,
                                             data:
                                                 *const c_void);
    pub fn evas_canvas_render_updates() -> *mut EinaList;
    pub fn evas_canvas_image_cache_flush();
    pub fn evas_canvas_coord_screen_y_to_world(y: c_int)
     -> EvasCoord;
    pub fn evas_canvas_key_modifier_del(keyname:
                                            *const c_char);
    pub fn evas_canvas_touch_point_list_nth_state_get(n:
                                                          c_uint)
     -> EvasTouchPointState;
    pub fn evas_canvas_focus_in();
    pub fn evas_canvas_obscured_rectangle_add(x: c_int,
                                              y: c_int,
                                              w: c_int,
                                              h: c_int);
    pub fn evas_canvas_render_dump();
    pub fn evas_canvas_event_feed_mouse_in(timestamp: c_uint,
                                           data:
                                               *const c_void);
    pub fn evas_canvas_object_top_in_rectangle_get(x: EvasCoord,
                                                   y: EvasCoord,
                                                   w: EvasCoord,
                                                   h: EvasCoord,
                                                   include_pass_events_objects:
                                                       EinaBool,
                                                   include_hidden_objects:
                                                       EinaBool)
     -> *mut EvasObject;
    pub fn evas_canvas_render();
    pub fn evas_canvas_event_feed_multi_up(d: c_int,
                                           x: c_int,
                                           y: c_int,
                                           rad: c_double,
                                           radx: c_double,
                                           rady: c_double,
                                           pres: c_double,
                                           ang: c_double,
                                           fx: c_double,
                                           fy: c_double,
                                           flags: EvasButtonFlags,
                                           timestamp: c_uint,
                                           data:
                                               *const c_void);
    pub fn evas_canvas_font_path_prepend(path: *const c_char);
    pub fn evas_canvas_obscured_clear();
    pub fn evas_canvas_event_feed_mouse_cancel(timestamp:
                                                   c_uint,
                                               data:
                                                   *const c_void);
    pub fn evas_canvas_coord_screen_x_to_world(x: c_int)
     -> EvasCoord;
    pub fn evas_canvas_key_lock_add(keyname: *const c_char);
    pub fn evas_canvas_render_idle_flush();
    pub fn evas_canvas_coord_world_y_to_screen(y: EvasCoord)
     -> c_int;
    pub fn evas_canvas_event_feed_key_down_with_keycode(keyname:
                                                            *const c_char,
                                                        key:
                                                            *const c_char,
                                                        string:
                                                            *const c_char,
                                                        compose:
                                                            *const c_char,
                                                        timestamp:
                                                            c_uint,
                                                        data:
                                                            *const c_void,
                                                        keycode:
                                                            c_uint);
    pub fn evas_canvas_event_feed_key_up_with_keycode(keyname:
                                                          *const c_char,
                                                      key:
                                                          *const c_char,
                                                      string:
                                                          *const c_char,
                                                      compose:
                                                          *const c_char,
                                                      timestamp:
                                                          c_uint,
                                                      data:
                                                          *const c_void,
                                                      keycode:
                                                          c_uint);
    pub fn evas_canvas_event_feed_axis_update(timestamp:
                                                  c_uint,
                                              device: c_int,
                                              toolid: c_int,
                                              naxes: c_int,
                                              axis: *const EvasAxis,
                                              data:
                                                  *const c_void);
    pub fn evas_rectangle_class_get() -> *const EoClass;
    pub fn evas_text_class_get() -> *const EoClass;
    pub fn evas_obj_text_shadow_color_set(r: c_int,
                                          g: c_int,
                                          b: c_int,
                                          a: c_int);
    pub fn evas_obj_text_shadow_color_get(r: *mut c_int,
                                          g: *mut c_int,
                                          b: *mut c_int,
                                          a: *mut c_int);
    pub fn evas_obj_text_ellipsis_set(ellipsis: c_double);
    pub fn evas_obj_text_ellipsis_get() -> c_double;
    pub fn evas_obj_text_bidi_delimiters_set(delim:
                                                 *const c_char);
    pub fn evas_obj_text_bidi_delimiters_get()
     -> *const c_char;
    pub fn evas_obj_text_outline_color_set(r: c_int,
                                           g: c_int,
                                           b: c_int,
                                           a: c_int);
    pub fn evas_obj_text_outline_color_get(r: *mut c_int,
                                           g: *mut c_int,
                                           b: *mut c_int,
                                           a: *mut c_int);
    pub fn evas_obj_text_glow2_color_set(r: c_int,
                                         g: c_int,
                                         b: c_int,
                                         a: c_int);
    pub fn evas_obj_text_glow2_color_get(r: *mut c_int,
                                         g: *mut c_int,
                                         b: *mut c_int,
                                         a: *mut c_int);
    pub fn evas_obj_text_style_set(style: EvasTextStyleType);
    pub fn evas_obj_text_style_get() -> EvasTextStyleType;
    pub fn evas_obj_text_glow_color_set(r: c_int,
                                        g: c_int,
                                        b: c_int,
                                        a: c_int);
    pub fn evas_obj_text_glow_color_get(r: *mut c_int,
                                        g: *mut c_int,
                                        b: *mut c_int,
                                        a: *mut c_int);
    pub fn evas_obj_text_max_descent_get() -> EvasCoord;
    pub fn evas_obj_text_style_pad_get(l: *mut c_int,
                                       r: *mut c_int,
                                       t: *mut c_int,
                                       b: *mut c_int);
    pub fn evas_obj_text_direction_get() -> EvasBidiDirection;
    pub fn evas_obj_text_ascent_get() -> EvasCoord;
    pub fn evas_obj_text_horiz_advance_get() -> EvasCoord;
    pub fn evas_obj_text_inset_get() -> EvasCoord;
    pub fn evas_obj_text_max_ascent_get() -> EvasCoord;
    pub fn evas_obj_text_vert_advance_get() -> EvasCoord;
    pub fn evas_obj_text_descent_get() -> EvasCoord;
    pub fn evas_obj_text_last_up_to_pos(x: EvasCoord, y: EvasCoord)
     -> c_int;
    pub fn evas_obj_text_char_coords_get(x: EvasCoord, y: EvasCoord,
                                         cx: *mut EvasCoord,
                                         cy: *mut EvasCoord,
                                         cw: *mut EvasCoord,
                                         ch: *mut EvasCoord)
     -> c_int;
    pub fn evas_obj_text_char_pos_get(pos: c_int,
                                      cx: *mut EvasCoord,
                                      cy: *mut EvasCoord,
                                      cw: *mut EvasCoord,
                                      ch: *mut EvasCoord) -> EinaBool;
    pub fn evas_textblock_class_get() -> *const EoClass;
    pub fn evas_obj_textblock_text_markup_set(text:
                                                  *const c_char);
    pub fn evas_obj_textblock_text_markup_get()
     -> *const c_char;
    pub fn evas_obj_textblock_valign_set(align: c_double);
    pub fn evas_obj_textblock_valign_get() -> c_double;
    pub fn evas_obj_textblock_bidi_delimiters_set(delim:
                                                      *const c_char);
    pub fn evas_obj_textblock_bidi_delimiters_get()
     -> *const c_char;
    pub fn evas_obj_textblock_replace_char_set(ch:
                                                   *const c_char);
    pub fn evas_obj_textblock_legacy_newline_set(mode: EinaBool);
    pub fn evas_obj_textblock_legacy_newline_get() -> EinaBool;
    pub fn evas_obj_textblock_style_set(ts: *const EvasTextblockStyle);
    pub fn evas_obj_textblock_style_get() -> *const EvasTextblockStyle;
    pub fn evas_obj_textblock_node_format_first_get()
     -> *const EvasTextblockNodeFormat;
    pub fn evas_obj_textblock_size_formatted_get(w: *mut EvasCoord,
                                                 h: *mut EvasCoord);
    pub fn evas_obj_textblock_node_format_last_get()
     -> *const EvasTextblockNodeFormat;
    pub fn evas_obj_textblock_cursor_get() -> *mut EvasTextblockCursor;
    pub fn evas_obj_textblock_size_native_get(w: *mut EvasCoord,
                                              h: *mut EvasCoord);
    pub fn evas_obj_textblock_style_insets_get(l: *mut EvasCoord,
                                               r: *mut EvasCoord,
                                               t: *mut EvasCoord,
                                               b: *mut EvasCoord);
    pub fn evas_obj_textblock_line_number_geometry_get(line:
                                                           c_int,
                                                       cx: *mut EvasCoord,
                                                       cy: *mut EvasCoord,
                                                       cw: *mut EvasCoord,
                                                       ch: *mut EvasCoord)
     -> EinaBool;
    pub fn evas_obj_textblock_replace_char_get()
     -> *const c_char;
    pub fn evas_obj_textblock_style_user_pop();
    pub fn evas_obj_textblock_cursor_new() -> *mut EvasTextblockCursor;
    pub fn evas_obj_textblock_node_format_list_get(anchor:
                                                       *const c_char)
     -> *const EinaList;
    pub fn evas_obj_textblock_style_user_peek()
     -> *const EvasTextblockStyle;
    pub fn evas_obj_textblock_node_format_remove_pair(n:
                                                          *mut EvasTextblockNodeFormat);
    pub fn evas_obj_textblock_clear();
    pub fn evas_obj_textblock_style_user_push(ts: *mut EvasTextblockStyle);
    pub fn evas_obj_textblock_obstacle_add(eo_obs: *mut EvasObject)
     -> EinaBool;
    pub fn evas_obj_textblock_obstacle_del(eo_obs: *mut EvasObject)
     -> EinaBool;
    pub fn evas_obj_textblock_obstacles_update();
    pub fn evas_textgrid_class_get() -> *const EoClass;
    pub fn evas_obj_textgrid_supported_font_styles_set(styles:
                                                           EvasTextgridFontStyle);
    pub fn evas_obj_textgrid_supported_font_styles_get()
     -> EvasTextgridFontStyle;
    pub fn evas_obj_textgrid_size_set(w: c_int,
                                      h: c_int);
    pub fn evas_obj_textgrid_size_get(w: *mut c_int,
                                      h: *mut c_int);
    pub fn evas_obj_textgrid_cell_size_get(width: *mut c_int,
                                           height:
                                               *mut c_int);
    pub fn evas_obj_textgrid_update_add(x: c_int,
                                        y: c_int,
                                        w: c_int,
                                        h: c_int);
    pub fn evas_obj_textgrid_cellrow_set(y: c_int,
                                         row: *const EvasTextgridCell);
    pub fn evas_obj_textgrid_cellrow_get(y: c_int)
     -> *mut EvasTextgridCell;
    pub fn evas_obj_textgrid_palette_set(pal: EvasTextgridPalette,
                                         idx: c_int,
                                         r: c_int,
                                         g: c_int,
                                         b: c_int,
                                         a: c_int);
    pub fn evas_obj_textgrid_palette_get(pal: EvasTextgridPalette,
                                         idx: c_int,
                                         r: *mut c_int,
                                         g: *mut c_int,
                                         b: *mut c_int,
                                         a: *mut c_int);
    pub fn evas_line_class_get() -> *const EoClass;
    pub fn evas_obj_line_xy_set(x1: EvasCoord, y1: EvasCoord,
                                x2: EvasCoord, y2: EvasCoord);
    pub fn evas_obj_line_xy_get(x1: *mut EvasCoord, y1: *mut EvasCoord,
                                x2: *mut EvasCoord, y2: *mut EvasCoord);
    pub fn evas_polygon_class_get() -> *const EoClass;
    pub fn evas_obj_polygon_point_add(x: EvasCoord, y: EvasCoord);
    pub fn evas_obj_polygon_points_clear();
    pub fn evas_object_smart_class_get() -> *const EoClass;
    pub fn evas_obj_smart_need_recalculate_set(value: EinaBool);
    pub fn evas_obj_smart_need_recalculate_get() -> EinaBool;
    pub fn evas_obj_smart_clip_set(clip: *mut EvasObject);
    pub fn evas_obj_smart_color_set(r: c_int,
                                    g: c_int,
                                    b: c_int,
                                    a: c_int);
    pub fn evas_obj_smart_data_set(data: *mut c_void);
    pub fn evas_obj_smart_members_get() -> *mut EinaList;
    pub fn evas_obj_smart_get() -> *mut EvasSmart;
    pub fn evas_obj_smart_show();
    pub fn evas_obj_smart_move(x: EvasCoord, y: EvasCoord);
    pub fn evas_obj_smart_callbacks_descriptions_set(descriptions:
                                                         *const EvasSmartCbDescription)
     -> EinaBool;
    pub fn evas_obj_smart_callbacks_descriptions_get(class_descriptions:
                                                         *mut *mut *const EvasSmartCbDescription,
                                                     class_count:
                                                         *mut c_uint,
                                                     instance_descriptions:
                                                         *mut *mut *const EvasSmartCbDescription,
                                                     instance_count:
                                                         *mut c_uint);
    pub fn evas_obj_smart_iterator_new() -> *mut EinaIterator;
    pub fn evas_obj_smart_callback_description_find(name:
                                                        *const c_char,
                                                    class_description:
                                                        *mut *const EvasSmartCbDescription,
                                                    instance_description:
                                                        *mut *const EvasSmartCbDescription);
    pub fn evas_obj_smart_hide();
    pub fn evas_obj_smart_calculate();
    pub fn evas_obj_smart_add();
    pub fn evas_obj_smart_member_add(sub_obj: *mut EvasObject);
    pub fn evas_obj_smart_resize(w: EvasCoord, h: EvasCoord);
    pub fn evas_obj_smart_clip_unset();
    pub fn evas_obj_smart_changed();
    pub fn evas_obj_smart_member_del(sub_obj: *mut EvasObject);
    pub fn evas_obj_smart_del();
    pub fn evas_obj_smart_attach(s: *mut EvasSmart);
    pub fn evas_smart_clipped_class_get() -> *const EoClass;
    pub fn evas_box_class_get() -> *const EoClass;
    pub fn evas_obj_box_align_set(horizontal: c_double,
                                  vertical: c_double);
    pub fn evas_obj_box_align_get(horizontal: *mut c_double,
                                  vertical: *mut c_double);
    pub fn evas_obj_box_padding_set(horizontal: EvasCoord,
                                    vertical: EvasCoord);
    pub fn evas_obj_box_padding_get(horizontal: *mut EvasCoord,
                                    vertical: *mut EvasCoord);
    pub fn evas_obj_box_layout_set(cb: EvasObjectBoxLayout,
                                   data: *const c_void,
                                   free_data: EinaFreeCb);
    pub fn evas_obj_box_layout_horizontal(_priv: *mut EvasObjectBoxData,
                                          data: *mut c_void);
    pub fn evas_obj_box_layout_vertical(_priv: *mut EvasObjectBoxData,
                                        data: *mut c_void);
    pub fn evas_obj_box_layout_homogeneous_max_size_horizontal(_priv:
                                                                   *mut EvasObjectBoxData,
                                                               data:
                                                                   *mut c_void);
    pub fn evas_obj_box_internal_remove(child: *mut EvasObject)
     -> *mut EvasObject;
    pub fn evas_obj_box_layout_flow_vertical(_priv: *mut EvasObjectBoxData,
                                             data:
                                                 *mut c_void);
    pub fn evas_obj_box_internal_option_free(opt:
                                                 *mut EvasObjectBoxOption);
    pub fn evas_obj_box_insert_after(child: *mut EvasObject,
                                     reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_remove_all(clear: EinaBool) -> EinaBool;
    pub fn evas_obj_box_iterator_new() -> *mut EinaIterator;
    pub fn evas_obj_box_add_to() -> *mut EvasObject;
    pub fn evas_obj_box_append(child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_option_property_id_get(name:
                                                   *const c_char)
     -> c_int;
    pub fn evas_obj_box_prepend(child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_accessor_new() -> *mut EinaAccessor;
    pub fn evas_obj_box_internal_append(child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
/*    pub fn evas_obj_box_option_property_vset(opt: *mut EvasObjectBoxOption,
                                             property: c_int,
                                             args: *mut va_list) -> EinaBool;
    pub fn evas_obj_box_internal_remove_at(pos: c_uint)
     -> *mut EvasObject;
*/
    pub fn evas_obj_box_remove_at(pos: c_uint) -> EinaBool;
/*    pub fn evas_obj_box_option_property_vget(opt: *mut EvasObjectBoxOption,
                                             property: c_int,
                                             args: *mut va_list) -> EinaBool;
*/
    pub fn evas_obj_box_internal_insert_at(child: *mut EvasObject,
                                           pos: c_uint)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_insert_before(child: *mut EvasObject,
                                      reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_option_property_name_get(property:
                                                     c_int)
     -> *const c_char;
    pub fn evas_obj_box_internal_insert_before(child: *mut EvasObject,
                                               reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_layout_homogeneous_horizontal(_priv:
                                                          *mut EvasObjectBoxData,
                                                      data:
                                                          *mut c_void);
    pub fn evas_obj_box_internal_option_new(child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_layout_homogeneous_max_size_vertical(_priv:
                                                                 *mut EvasObjectBoxData,
                                                             data:
                                                                 *mut c_void);
    pub fn evas_obj_box_internal_insert_after(child: *mut EvasObject,
                                              reference: *const EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_insert_at(child: *mut EvasObject,
                                  pos: c_uint)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_internal_prepend(child: *mut EvasObject)
     -> *mut EvasObjectBoxOption;
    pub fn evas_obj_box_remove(child: *mut EvasObject) -> EinaBool;
    pub fn evas_obj_box_layout_stack(_priv: *mut EvasObjectBoxData,
                                     data: *mut c_void);
    pub fn evas_obj_box_layout_homogeneous_vertical(_priv:
                                                        *mut EvasObjectBoxData,
                                                    data:
                                                        *mut c_void);
    pub fn evas_obj_box_layout_flow_horizontal(_priv:
                                                   *mut EvasObjectBoxData,
                                               data:
                                                   *mut c_void);
    pub fn evas_table_class_get() -> *const EoClass;
    pub fn evas_obj_table_homogeneous_set(homogeneous:
                                              EvasObjectTableHomogeneousMode);
    pub fn evas_obj_table_homogeneous_get()
     -> EvasObjectTableHomogeneousMode;
    pub fn evas_obj_table_align_set(horizontal: c_double,
                                    vertical: c_double);
    pub fn evas_obj_table_align_get(horizontal: *mut c_double,
                                    vertical: *mut c_double);
    pub fn evas_obj_table_padding_set(horizontal: EvasCoord,
                                      vertical: EvasCoord);
    pub fn evas_obj_table_padding_get(horizontal: *mut EvasCoord,
                                      vertical: *mut EvasCoord);
    pub fn evas_obj_table_mirrored_set(mirrored: EinaBool);
    pub fn evas_obj_table_mirrored_get() -> EinaBool;
    pub fn evas_obj_table_col_row_size_get(cols: *mut c_int,
                                           rows: *mut c_int);
    pub fn evas_obj_table_children_get() -> *mut EinaList;
    pub fn evas_obj_table_child_get(col: c_ushort,
                                    row: c_ushort)
     -> *mut EvasObject;
    pub fn evas_obj_table_clear(clear: EinaBool);
    pub fn evas_obj_table_accessor_new() -> *mut EinaAccessor;
    pub fn evas_obj_table_iterator_new() -> *mut EinaIterator;
    pub fn evas_obj_table_add_to() -> *mut EvasObject;
    pub fn evas_obj_table_pack_get(child: *mut EvasObject,
                                   col: *mut c_ushort,
                                   row: *mut c_ushort,
                                   colspan: *mut c_ushort,
                                   rowspan: *mut c_ushort)
     -> EinaBool;
    pub fn evas_obj_table_pack(child: *mut EvasObject,
                               col: c_ushort,
                               row: c_ushort,
                               colspan: c_ushort,
                               rowspan: c_ushort)
     -> EinaBool;
    pub fn evas_obj_table_unpack(child: *mut EvasObject) -> EinaBool;
    pub fn evas_grid_class_get() -> *const EoClass;
    pub fn evas_obj_grid_mirrored_set(mirrored: EinaBool);
    pub fn evas_obj_grid_mirrored_get() -> EinaBool;
    pub fn evas_obj_grid_size_set(w: c_int,
                                  h: c_int);
    pub fn evas_obj_grid_size_get(w: *mut c_int,
                                  h: *mut c_int);
    pub fn evas_obj_grid_children_get() -> *mut EinaList;
    pub fn evas_obj_grid_accessor_new() -> *mut EinaAccessor;
    pub fn evas_obj_grid_clear(clear: EinaBool);
    pub fn evas_obj_grid_iterator_new() -> *mut EinaIterator;
    pub fn evas_obj_grid_add_to() -> *mut EvasObject;
    pub fn evas_obj_grid_unpack(child: *mut EvasObject) -> EinaBool;
    pub fn evas_obj_grid_pack_get(child: *mut EvasObject,
                                  x: *mut c_int,
                                  y: *mut c_int,
                                  w: *mut c_int,
                                  h: *mut c_int) -> EinaBool;
    pub fn evas_obj_grid_pack(child: *mut EvasObject,
                              x: c_int,
                              y: c_int,
                              w: c_int,
                              h: c_int) -> EinaBool;
    pub fn evas_common_interface_interface_get() -> *const EoClass;
    pub fn evas_common_evas_get() -> *mut EvasCommonInterface;
    pub fn evas_object_class_get() -> *const EoClass;
    pub fn evas_obj_size_hint_max_set(w: EvasCoord, h: EvasCoord);
    pub fn evas_obj_size_hint_max_get(w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_obj_size_hint_request_set(w: EvasCoord, h: EvasCoord);
    pub fn evas_obj_size_hint_request_get(w: *mut EvasCoord,
                                          h: *mut EvasCoord);
    pub fn evas_obj_type_set(_type: *const c_char);
    pub fn evas_obj_type_get() -> *const c_char;
    pub fn evas_obj_size_hint_min_set(w: EvasCoord, h: EvasCoord);
    pub fn evas_obj_size_hint_min_get(w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_obj_pointer_mode_set(pointer_mode: EvasObjectPointerMode);
    pub fn evas_obj_pointer_mode_get() -> EvasObjectPointerMode;
    pub fn evas_obj_render_op_set(render_op: EvasRenderOp);
    pub fn evas_obj_render_op_get() -> EvasRenderOp;
    pub fn evas_obj_freeze_events_set(freeze: EinaBool);
    pub fn evas_obj_freeze_events_get() -> EinaBool;
    pub fn evas_obj_map_set(map: *const EvasMap);
    pub fn evas_obj_map_get() -> *const EvasMap;
    pub fn evas_obj_size_hint_aspect_set(aspect: EvasAspectControl,
                                         w: EvasCoord, h: EvasCoord);
    pub fn evas_obj_size_hint_aspect_get(aspect: *mut EvasAspectControl,
                                         w: *mut EvasCoord,
                                         h: *mut EvasCoord);
    pub fn evas_obj_clip_set(clip: *mut EvasObject);
    pub fn evas_obj_clip_get() -> *mut EvasObject;
    pub fn evas_obj_size_hint_padding_set(l: EvasCoord, r: EvasCoord,
                                          t: EvasCoord, b: EvasCoord);
    pub fn evas_obj_size_hint_padding_get(l: *mut EvasCoord,
                                          r: *mut EvasCoord,
                                          t: *mut EvasCoord,
                                          b: *mut EvasCoord);
    pub fn evas_obj_repeat_events_set(repeat: EinaBool);
    pub fn evas_obj_repeat_events_get() -> EinaBool;
    pub fn evas_obj_size_hint_weight_set(x: c_double,
                                         y: c_double);
    pub fn evas_obj_size_hint_weight_get(x: *mut c_double,
                                         y: *mut c_double);
    pub fn evas_obj_name_set(name: *const c_char);
    pub fn evas_obj_name_get() -> *const c_char;
    pub fn evas_obj_scale_set(scale: c_double);
    pub fn evas_obj_scale_get() -> c_double;
    pub fn evas_obj_static_clip_set(is_static_clip: EinaBool);
    pub fn evas_obj_static_clip_get() -> EinaBool;
    pub fn evas_obj_focus_set(focus: EinaBool);
    pub fn evas_obj_focus_get() -> EinaBool;
    pub fn evas_obj_is_frame_object_set(is_frame: EinaBool);
    pub fn evas_obj_is_frame_object_get() -> EinaBool;
    pub fn evas_obj_map_enable_set(enabled: EinaBool);
    pub fn evas_obj_map_enable_get() -> EinaBool;
    pub fn evas_obj_precise_is_inside_set(precise: EinaBool);
    pub fn evas_obj_precise_is_inside_get() -> EinaBool;
    pub fn evas_obj_size_hint_align_set(x: c_double,
                                        y: c_double);
    pub fn evas_obj_size_hint_align_get(x: *mut c_double,
                                        y: *mut c_double);
    pub fn evas_obj_propagate_events_set(propagate: EinaBool);
    pub fn evas_obj_propagate_events_get() -> EinaBool;
    pub fn evas_obj_pass_events_set(pass: EinaBool);
    pub fn evas_obj_pass_events_get() -> EinaBool;
    pub fn evas_obj_anti_alias_set(anti_alias: EinaBool);
    pub fn evas_obj_anti_alias_get() -> EinaBool;
    pub fn evas_obj_smart_data_get() -> *mut c_void;
    pub fn evas_obj_smart_clipped_clipper_get() -> *mut EvasObject;
    pub fn evas_obj_clipees_get() -> *const EinaList;
    pub fn evas_obj_smart_parent_get() -> *mut EvasObject;
    pub fn evas_obj_size_hint_display_mode_set(dispmode: EvasDisplayMode);
    pub fn evas_obj_size_hint_display_mode_get() -> EvasDisplayMode;
    pub fn evas_obj_no_render_set(enable: EinaBool);
    pub fn evas_obj_no_render_get() -> EinaBool;
    pub fn evas_obj_clipees_has() -> EinaBool;
    pub fn evas_obj_key_grab(keyname: *const c_char,
                             modifiers: EvasModifierMask,
                             not_modifiers: EvasModifierMask,
                             exclusive: EinaBool) -> EinaBool;
    pub fn evas_obj_smart_type_check(_type: *const c_char)
     -> EinaBool;
    pub fn evas_obj_name_child_find(name: *const c_char,
                                    recurse: c_int)
     -> *mut EvasObject;
    pub fn evas_obj_key_ungrab(keyname: *const c_char,
                               modifiers: EvasModifierMask,
                               not_modifiers: EvasModifierMask);
    pub fn evas_obj_clip_unset();
    pub fn evas_obj_smart_move_children_relative(dx: EvasCoord,
                                                 dy: EvasCoord);
    pub fn evas_obj_smart_type_check_ptr(_type: *const c_char)
     -> EinaBool;
    pub fn evas_out_class_get() -> *const EoClass;
    pub fn evas_out_view_set(x: EvasCoord, y: EvasCoord, w: EvasCoord,
                             h: EvasCoord);
    pub fn evas_out_view_get(x: *mut EvasCoord, y: *mut EvasCoord,
                             w: *mut EvasCoord, h: *mut EvasCoord);
    pub fn evas_out_engine_info_set(info: *mut EvasEngineInfo) -> EinaBool;
    pub fn evas_out_engine_info_get() -> *mut EvasEngineInfo;
    pub fn evas_canvas3d_object_class_get() -> *const EoClass;
    pub fn evas_canvas3d_object_update_notify();
    pub fn evas_canvas3d_object_change_notify(state: EvasCanvas3DState,
                                              _ref:
                                                  *mut EvasCanvas3DObject);
    pub fn evas_canvas3d_object_callback_register(event:
                                                      *const c_char,
                                                  data:
                                                      *const c_void);
    pub fn evas_canvas3d_object_callback_unregister(event:
                                                        *const c_char);
    pub fn evas_canvas3d_object_change(state: EvasCanvas3DState,
                                       _ref: *mut EvasCanvas3DObject);
    pub fn evas_canvas3d_object_type_get() -> EvasCanvas3DObjectType;
    pub fn evas_canvas3d_object_type_set(_type: EvasCanvas3DObjectType);
    pub fn evas_canvas3d_object_dirty_get(state: EvasCanvas3DState)
     -> EinaBool;
    pub fn evas_canvas3d_object_update();
    pub fn evas_canvas3d_texture_class_get() -> *const EoClass;
    pub fn evas_canvas3d_texture_source_visible_set(visible: EinaBool);
    pub fn evas_canvas3d_texture_source_visible_get() -> EinaBool;
    pub fn evas_canvas3d_texture_atlas_enable_set(use_atlas: EinaBool);
    pub fn evas_canvas3d_texture_atlas_enable_get() -> EinaBool;
    pub fn evas_canvas3d_texture_data_set(color_format: EvasColorspace,
                                          w: c_int,
                                          h: c_int,
                                          data:
                                              *const c_void);
    pub fn evas_canvas3d_texture_file_set(file: *const c_char,
                                          key: *const c_char);
    pub fn evas_canvas3d_texture_source_set(source: *mut EvasObject);
    pub fn evas_canvas3d_texture_color_format_get() -> EvasColorspace;
    pub fn evas_canvas3d_texture_size_get(w: *mut c_int,
                                          h: *mut c_int);
    pub fn evas_canvas3d_texture_wrap_set(s: EvasCanvas3DWrapMode,
                                          t: EvasCanvas3DWrapMode);
    pub fn evas_canvas3d_texture_wrap_get(s: *mut EvasCanvas3DWrapMode,
                                          t: *mut EvasCanvas3DWrapMode);
    pub fn evas_canvas3d_texture_filter_set(min: EvasCanvas3DTextureFilter,
                                            mag:
                                                EvasCanvas3DTextureFilter);
    pub fn evas_canvas3d_texture_filter_get(min:
                                                *mut EvasCanvas3DTextureFilter,
                                            mag:
                                                *mut EvasCanvas3DTextureFilter);
    pub fn evas_canvas3d_material_class_get() -> *const EoClass;
    pub fn evas_canvas3d_material_enable_set(attrib:
                                                 EvasCanvas3DMaterialAttrib,
                                             enable: EinaBool);
    pub fn evas_canvas3d_material_enable_get(attrib:
                                                 EvasCanvas3DMaterialAttrib)
     -> EinaBool;
    pub fn evas_canvas3d_material_shininess_set(shininess: EvasReal);
    pub fn evas_canvas3d_material_shininess_get() -> EvasReal;
    pub fn evas_canvas3d_material_texture_set(attrib:
                                                  EvasCanvas3DMaterialAttrib,
                                              texture:
                                                  *mut EvasCanvas3DTexture);
    pub fn evas_canvas3d_material_texture_get(attrib:
                                                  EvasCanvas3DMaterialAttrib)
     -> *mut EvasCanvas3DTexture;
    pub fn evas_canvas3d_material_color_set(attrib:
                                                EvasCanvas3DMaterialAttrib,
                                            r: EvasReal, g: EvasReal,
                                            b: EvasReal, a: EvasReal);
    pub fn evas_canvas3d_material_color_get(attrib:
                                                EvasCanvas3DMaterialAttrib,
                                            r: *mut EvasReal,
                                            g: *mut EvasReal,
                                            b: *mut EvasReal,
                                            a: *mut EvasReal);
    pub fn evas_canvas3d_light_class_get() -> *const EoClass;
    pub fn evas_canvas3d_light_directional_set(directional: EinaBool);
    pub fn evas_canvas3d_light_directional_get() -> EinaBool;
    pub fn evas_canvas3d_light_spot_exponent_set(exponent: EvasReal);
    pub fn evas_canvas3d_light_spot_exponent_get() -> EvasReal;
    pub fn evas_canvas3d_light_spot_cutoff_set(cutoff: EvasReal);
    pub fn evas_canvas3d_light_spot_cutoff_get() -> EvasReal;
    pub fn evas_canvas3d_light_attenuation_enable_set(enable: EinaBool);
    pub fn evas_canvas3d_light_attenuation_enable_get() -> EinaBool;
    pub fn evas_canvas3d_light_ambient_set(r: EvasReal, g: EvasReal,
                                           b: EvasReal, a: EvasReal);
    pub fn evas_canvas3d_light_ambient_get(r: *mut EvasReal,
                                           g: *mut EvasReal,
                                           b: *mut EvasReal,
                                           a: *mut EvasReal);
    pub fn evas_canvas3d_light_diffuse_set(r: EvasReal, g: EvasReal,
                                           b: EvasReal, a: EvasReal);
    pub fn evas_canvas3d_light_diffuse_get(r: *mut EvasReal,
                                           g: *mut EvasReal,
                                           b: *mut EvasReal,
                                           a: *mut EvasReal);
    pub fn evas_canvas3d_light_specular_set(r: EvasReal, g: EvasReal,
                                            b: EvasReal, a: EvasReal);
    pub fn evas_canvas3d_light_specular_get(r: *mut EvasReal,
                                            g: *mut EvasReal,
                                            b: *mut EvasReal,
                                            a: *mut EvasReal);
    pub fn evas_canvas3d_light_attenuation_set(constant: EvasReal,
                                               linear: EvasReal,
                                               quadratic: EvasReal);
    pub fn evas_canvas3d_light_attenuation_get(constant: *mut EvasReal,
                                               linear: *mut EvasReal,
                                               quadratic: *mut EvasReal);
    pub fn evas_canvas3d_light_projection_matrix_set(matrix:
                                                         *const EvasReal);
    pub fn evas_canvas3d_light_projection_matrix_get(matrix: *mut EvasReal);
    pub fn evas_canvas3d_light_projection_perspective_set(fovy: EvasReal,
                                                          aspect: EvasReal,
                                                          dnear: EvasReal,
                                                          dfar: EvasReal);
    pub fn evas_canvas3d_light_projection_frustum_set(left: EvasReal,
                                                      right: EvasReal,
                                                      bottom: EvasReal,
                                                      top: EvasReal,
                                                      dnear: EvasReal,
                                                      dfar: EvasReal);
    pub fn evas_canvas3d_light_projection_ortho_set(left: EvasReal,
                                                    right: EvasReal,
                                                    bottom: EvasReal,
                                                    top: EvasReal,
                                                    dnear: EvasReal,
                                                    dfar: EvasReal);
    pub fn evas_canvas3d_primitive_class_get() -> *const EoClass;
    pub fn evas_canvas3d_primitive_form_set(form:
                                                EvasCanvas3DMeshPrimitive);
    pub fn evas_canvas3d_primitive_form_get() -> EvasCanvas3DMeshPrimitive;
    pub fn evas_canvas3d_primitive_mode_set(mode:
                                                EvasCanvas3DPrimitiveMode);
    pub fn evas_canvas3d_primitive_mode_get() -> EvasCanvas3DPrimitiveMode;
    pub fn evas_canvas3d_primitive_ratio_set(ratio: EvasReal);
    pub fn evas_canvas3d_primitive_ratio_get() -> EvasReal;
    pub fn evas_canvas3d_primitive_precision_set(precision:
                                                     c_int);
    pub fn evas_canvas3d_primitive_precision_get() -> c_int;
    pub fn evas_canvas3d_primitive_surface_set(surface:
                                                   *mut EvasCanvas3DSurfaceFunc);
    pub fn evas_canvas3d_primitive_tex_scale_set(tex_scale_x: EvasReal,
                                                 tex_scale_y: EvasReal);
    pub fn evas_canvas3d_primitive_tex_scale_get(tex_scale_x: *mut EvasReal,
                                                 tex_scale_y: *mut EvasReal);
    pub fn evas_canvas3d_mesh_class_get() -> *const EoClass;
    pub fn evas_canvas3d_mesh_shade_mode_set(mode: EvasCanvas3DShadeMode);
    pub fn evas_canvas3d_mesh_shade_mode_get() -> EvasCanvas3DShadeMode;
    pub fn evas_canvas3d_mesh_color_pick_enable_set(enabled: EinaBool);
    pub fn evas_canvas3d_mesh_color_pick_enable_get() -> EinaBool;
    pub fn evas_canvas3d_mesh_vertex_count_set(count: c_uint);
    pub fn evas_canvas3d_mesh_vertex_count_get() -> c_uint;
    pub fn evas_canvas3d_mesh_fog_enable_set(enabled: EinaBool);
    pub fn evas_canvas3d_mesh_fog_enable_get() -> EinaBool;
    pub fn evas_canvas3d_mesh_alpha_test_enable_set(enabled: EinaBool);
    pub fn evas_canvas3d_mesh_alpha_test_enable_get() -> EinaBool;
    pub fn evas_canvas3d_mesh_alpha_func_set(comparison_func:
                                                 EvasCanvas3DComparison,
                                             ref_value: EvasReal);
    pub fn evas_canvas3d_mesh_alpha_func_get(comparison_func:
                                                 *mut EvasCanvas3DComparison,
                                             ref_value: *mut EvasReal);
    pub fn evas_canvas3d_mesh_blending_enable_set(blending: EinaBool);
    pub fn evas_canvas3d_mesh_blending_enable_get() -> EinaBool;
    pub fn evas_canvas3d_mesh_frame_material_set(frame: c_int,
                                                 material:
                                                     *mut EvasCanvas3DMaterial);
    pub fn evas_canvas3d_mesh_frame_material_get(frame: c_int)
     -> *mut EvasCanvas3DMaterial;
    pub fn evas_canvas3d_mesh_vertex_assembly_set(assembly:
                                                      EvasCanvas3DVertexAssembly);
    pub fn evas_canvas3d_mesh_vertex_assembly_get()
     -> EvasCanvas3DVertexAssembly;
    pub fn evas_canvas3d_mesh_shadows_edges_filtering_set(blur_level:
                                                              c_int,
                                                          edges_size:
                                                              EvasReal);
    pub fn evas_canvas3d_mesh_shadows_edges_filtering_get(blur_level:
                                                              *mut c_int,
                                                          edges_size:
                                                              *mut EvasReal);
    pub fn evas_canvas3d_mesh_shadows_constant_bias_set(bias: EvasReal);
    pub fn evas_canvas3d_mesh_shadows_constant_bias_get() -> EvasReal;
    pub fn evas_canvas3d_mesh_frame_vertex_data_set(frame:
                                                        c_int,
                                                    attrib:
                                                        EvasCanvas3DVertexAttrib,
                                                    stride:
                                                        c_int,
                                                    data:
                                                        *const c_void);
    pub fn evas_canvas3d_mesh_frame_vertex_data_copy_set(frame:
                                                             c_int,
                                                         attrib:
                                                             EvasCanvas3DVertexAttrib,
                                                         stride:
                                                             c_int,
                                                         data:
                                                             *const c_void);
    pub fn evas_canvas3d_mesh_frame_vertex_data_map(frame:
                                                        c_int,
                                                    attrib:
                                                        EvasCanvas3DVertexAttrib)
     -> *mut c_void;
    pub fn evas_canvas3d_mesh_frame_vertex_data_unmap(frame:
                                                          c_int,
                                                      attrib:
                                                          EvasCanvas3DVertexAttrib);
    pub fn evas_canvas3d_mesh_frame_vertex_stride_get(frame:
                                                          c_int,
                                                      attrib:
                                                          EvasCanvas3DVertexAttrib)
     -> c_int;
    pub fn evas_canvas3d_mesh_index_data_set(format:
                                                 EvasCanvas3DIndexFormat,
                                             count: c_int,
                                             indices:
                                                 *const c_void);
    pub fn evas_canvas3d_mesh_index_data_copy_set(format:
                                                      EvasCanvas3DIndexFormat,
                                                  count:
                                                      c_int,
                                                  indices:
                                                      *const c_void);
    pub fn evas_canvas3d_mesh_index_format_get()
     -> EvasCanvas3DIndexFormat;
    pub fn evas_canvas3d_mesh_index_count_get() -> c_int;
    pub fn evas_canvas3d_mesh_index_data_map() -> *mut c_void;
    pub fn evas_canvas3d_mesh_index_data_unmap();
    pub fn evas_canvas3d_mesh_frame_exist(frame: c_int)
     -> EinaBool;
    pub fn evas_canvas3d_mesh_frame_add(frame: c_int);
    pub fn evas_canvas3d_mesh_frame_del(frame: c_int);
    pub fn evas_canvas3d_mesh_fog_color_set(r: EvasReal, g: EvasReal,
                                            b: EvasReal, a: EvasReal);
    pub fn evas_canvas3d_mesh_fog_color_get(r: *mut EvasReal,
                                            g: *mut EvasReal,
                                            b: *mut EvasReal,
                                            a: *mut EvasReal);
    pub fn evas_canvas3d_mesh_blending_func_set(sfactor:
                                                    EvasCanvas3DBlendFunc,
                                                dfactor:
                                                    EvasCanvas3DBlendFunc);
    pub fn evas_canvas3d_mesh_blending_func_get(sfactor:
                                                    *mut EvasCanvas3DBlendFunc,
                                                dfactor:
                                                    *mut EvasCanvas3DBlendFunc);
    pub fn evas_canvas3d_mesh_from_primitive_set(frame: c_int,
                                                 primitive:
                                                     *mut EvasCanvas3DPrimitive);
    pub fn evas_canvas3d_node_class_get() -> *const EoClass;
    pub fn evas_canvas3d_node_position_inherit_set(inherit: EinaBool);
    pub fn evas_canvas3d_node_position_inherit_get() -> EinaBool;
    pub fn evas_canvas3d_node_orientation_inherit_set(inherit: EinaBool);
    pub fn evas_canvas3d_node_orientation_inherit_get() -> EinaBool;
    pub fn evas_canvas3d_node_scale_inherit_set(inherit: EinaBool);
    pub fn evas_canvas3d_node_scale_inherit_get() -> EinaBool;
    pub fn evas_canvas3d_node_camera_set(camera: *mut EvasCanvas3DObject);
    pub fn evas_canvas3d_node_camera_get() -> *mut EvasCanvas3DObject;
    pub fn evas_canvas3d_node_light_set(light: *mut EvasCanvas3DLight);
    pub fn evas_canvas3d_node_light_get() -> *mut EvasCanvas3DLight;
    pub fn evas_canvas3d_node_mesh_frame_set(mesh: *mut EvasCanvas3DMesh,
                                             frame: c_int);
    pub fn evas_canvas3d_node_mesh_frame_get(mesh: *mut EvasCanvas3DMesh)
     -> c_int;
    pub fn evas_canvas3d_node_billboard_target_set(target:
                                                       *mut EvasCanvas3DNode);
    pub fn evas_canvas3d_node_billboard_target_get()
     -> *mut EvasCanvas3DNode;
    pub fn evas_canvas3d_node_constructor(_type: EvasCanvas3DNodeType);
    pub fn evas_canvas3d_node_type_get() -> EvasCanvas3DNodeType;
    pub fn evas_canvas3d_node_member_add(member: *mut EvasCanvas3DNode);
    pub fn evas_canvas3d_node_member_del(member: *mut EvasCanvas3DNode);
    pub fn evas_canvas3d_node_parent_get() -> *mut EvasCanvas3DNode;
    pub fn evas_canvas3d_node_member_list_get() -> *const EinaList;
    pub fn evas_canvas3d_node_position_set(x: EvasReal, y: EvasReal,
                                           z: EvasReal);
    pub fn evas_canvas3d_node_orientation_set(x: EvasReal, y: EvasReal,
                                              z: EvasReal, w: EvasReal);
    pub fn evas_canvas3d_node_orientation_angle_axis_set(angle: EvasReal,
                                                         x: EvasReal,
                                                         y: EvasReal,
                                                         z: EvasReal);
    pub fn evas_canvas3d_node_scale_set(x: EvasReal, y: EvasReal,
                                        z: EvasReal);
    pub fn evas_canvas3d_node_position_get(space: EvasCanvas3DSpace,
                                           x: *mut EvasReal,
                                           y: *mut EvasReal,
                                           z: *mut EvasReal);
    pub fn evas_canvas3d_node_orientation_get(space: EvasCanvas3DSpace,
                                              x: *mut EvasReal,
                                              y: *mut EvasReal,
                                              z: *mut EvasReal,
                                              w: *mut EvasReal);
    pub fn evas_canvas3d_node_scale_get(space: EvasCanvas3DSpace,
                                        x: *mut EvasReal, y: *mut EvasReal,
                                        z: *mut EvasReal);
    pub fn evas_canvas3d_node_look_at_set(target_space: EvasCanvas3DSpace,
                                          x: EvasReal, y: EvasReal,
                                          z: EvasReal,
                                          up_space: EvasCanvas3DSpace,
                                          ux: EvasReal, uy: EvasReal,
                                          uz: EvasReal);
    pub fn evas_canvas3d_node_mesh_add(mesh: *mut EvasCanvas3DMesh);
    pub fn evas_canvas3d_node_mesh_del(mesh: *mut EvasCanvas3DMesh);
    pub fn evas_canvas3d_node_mesh_list_get() -> *const EinaList;
    pub fn evas_canvas3d_node_bounding_box_get(x: *mut EvasReal,
                                               y: *mut EvasReal,
                                               z: *mut EvasReal,
                                               x2: *mut EvasReal,
                                               y2: *mut EvasReal,
                                               z2: *mut EvasReal);
    pub fn evas_canvas3d_node_bounding_sphere_get(x: *mut EvasReal,
                                                  y: *mut EvasReal,
                                                  z: *mut EvasReal,
                                                  r: *mut EvasReal);
    pub fn evas_canvas3d_camera_class_get() -> *const EoClass;
    pub fn evas_canvas3d_camera_projection_matrix_set(matrix:
                                                          *const EvasReal);
    pub fn evas_canvas3d_camera_projection_matrix_get(matrix: *mut EvasReal);
    pub fn evas_canvas3d_camera_projection_perspective_set(fovy: EvasReal,
                                                           aspect: EvasReal,
                                                           dnear: EvasReal,
                                                           dfar: EvasReal);
    pub fn evas_canvas3d_camera_projection_frustum_set(left: EvasReal,
                                                       right: EvasReal,
                                                       bottom: EvasReal,
                                                       top: EvasReal,
                                                       dnear: EvasReal,
                                                       dfar: EvasReal);
    pub fn evas_canvas3d_camera_projection_ortho_set(left: EvasReal,
                                                     right: EvasReal,
                                                     bottom: EvasReal,
                                                     top: EvasReal,
                                                     dnear: EvasReal,
                                                     dfar: EvasReal);
    pub fn evas_canvas3d_camera_node_visible_get(camera_node:
                                                     *mut EvasCanvas3DNode,
                                                 node:
                                                     *mut EvasCanvas3DNode,
                                                 key:
                                                     EvasCanvas3DFrustumMode)
     -> EinaBool;
    pub fn evas_canvas3d_scene_class_get() -> *const EoClass;
    pub fn evas_canvas3d_scene_root_node_set(node: *mut EvasCanvas3DNode);
    pub fn evas_canvas3d_scene_root_node_get() -> *mut EvasCanvas3DNode;
    pub fn evas_canvas3d_scene_camera_node_set(node: *mut EvasCanvas3DNode);
    pub fn evas_canvas3d_scene_camera_node_get() -> *mut EvasCanvas3DNode;
    pub fn evas_canvas3d_scene_shadows_depth_set(depth_offset: EvasReal,
                                                 depth_constant: EvasReal);
    pub fn evas_canvas3d_scene_shadows_depth_get(depth_offset: *mut EvasReal,
                                                 depth_constant:
                                                     *mut EvasReal);
    pub fn evas_canvas3d_scene_size_set(w: c_int,
                                        h: c_int);
    pub fn evas_canvas3d_scene_size_get(w: *mut c_int,
                                        h: *mut c_int);
    pub fn evas_canvas3d_scene_background_color_set(r: EvasReal,
                                                    g: EvasReal,
                                                    b: EvasReal,
                                                    a: EvasReal);
    pub fn evas_canvas3d_scene_background_color_get(r: *mut EvasReal,
                                                    g: *mut EvasReal,
                                                    b: *mut EvasReal,
                                                    a: *mut EvasReal);
    pub fn evas_canvas3d_scene_pick(x: EvasReal, y: EvasReal,
                                    node: *mut *mut EvasCanvas3DNode,
                                    mesh: *mut *mut EvasCanvas3DMesh,
                                    s: *mut EvasReal, t: *mut EvasReal)
     -> EinaBool;
    pub fn evas_canvas3d_scene_exist(x: EvasReal, y: EvasReal,
                                     node: *mut EvasCanvas3DNode)
     -> *mut EvasCanvas3DNode;
    pub fn evas_canvas3d_scene_pick_member_list_get(x: EvasReal,
                                                    y: EvasReal)
     -> *mut EinaList;
    pub fn evas_canvas3d_scene_shadows_enable_set(shadows_enabled: EinaBool);
    pub fn evas_canvas3d_scene_shadows_enable_get() -> EinaBool;
    pub fn evas_canvas3d_scene_color_pick_enable_get() -> EinaBool;
    pub fn evas_canvas3d_scene_color_pick_enable_set(color_pick: EinaBool)
     -> EinaBool;
    pub fn evas_image_class_get() -> *const EoClass;
    pub fn evas_obj_image_load_dpi_set(dpi: c_double);
    pub fn evas_obj_image_load_dpi_get() -> c_double;
    pub fn evas_obj_image_source_clip_set(source_clip: EinaBool);
    pub fn evas_obj_image_source_clip_get() -> EinaBool;
    pub fn evas_obj_image_source_set(src: *mut EvasObject) -> EinaBool;
    pub fn evas_obj_image_source_get() -> *mut EvasObject;
    pub fn evas_obj_image_filled_set(filled: EinaBool);
    pub fn evas_obj_image_filled_get() -> EinaBool;
    pub fn evas_obj_image_content_hint_set(hint: EvasImageContentHint);
    pub fn evas_obj_image_content_hint_get() -> EvasImageContentHint;
    pub fn evas_obj_image_load_region_set(x: c_int,
                                          y: c_int,
                                          w: c_int,
                                          h: c_int);
    pub fn evas_obj_image_load_region_get(x: *mut c_int,
                                          y: *mut c_int,
                                          w: *mut c_int,
                                          h: *mut c_int);
    pub fn evas_obj_image_alpha_set(alpha: EinaBool);
    pub fn evas_obj_image_alpha_get() -> EinaBool;
    pub fn evas_obj_image_border_set(l: c_int,
                                     r: c_int,
                                     t: c_int,
                                     b: c_int);
    pub fn evas_obj_image_border_get(l: *mut c_int,
                                     r: *mut c_int,
                                     t: *mut c_int,
                                     b: *mut c_int);
    pub fn evas_obj_image_border_scale_set(scale: c_double);
    pub fn evas_obj_image_border_scale_get() -> c_double;
    pub fn evas_obj_image_pixels_dirty_set(dirty: EinaBool);
    pub fn evas_obj_image_pixels_dirty_get() -> EinaBool;
    pub fn evas_obj_image_video_surface_set(surf: *mut EvasVideoSurface);
    pub fn evas_obj_image_video_surface_get() -> *const EvasVideoSurface;
    pub fn evas_obj_image_video_surface_caps_set(caps:
                                                     c_uint);
    pub fn evas_obj_image_video_surface_caps_get() -> c_uint;
    pub fn evas_obj_image_load_orientation_set(enable: EinaBool);
    pub fn evas_obj_image_load_orientation_get() -> EinaBool;
    pub fn evas_obj_image_border_center_fill_set(fill: EvasBorderFillMode);
    pub fn evas_obj_image_border_center_fill_get() -> EvasBorderFillMode;
    pub fn evas_obj_image_source_visible_set(visible: EinaBool);
    pub fn evas_obj_image_source_visible_get() -> EinaBool;
    pub fn evas_obj_image_native_surface_set(surf: *mut EvasNativeSurface);
    pub fn evas_obj_image_native_surface_get() -> *mut EvasNativeSurface;
    pub fn evas_obj_image_load_scale_down_set(scale_down:
                                                  c_int);
    pub fn evas_obj_image_load_scale_down_get() -> c_int;
    pub fn evas_obj_image_scale_hint_set(hint: EvasImageScaleHint);
    pub fn evas_obj_image_scale_hint_get() -> EvasImageScaleHint;
    pub fn evas_obj_image_source_events_set(source: EinaBool);
    pub fn evas_obj_image_source_events_get() -> EinaBool;
    pub fn evas_obj_image_colorspace_set(cspace: EvasColorspace);
    pub fn evas_obj_image_colorspace_get() -> EvasColorspace;
    pub fn evas_obj_image_pixels_get_callback_set(func:
                                                      EvasObjectImagePixelsGetCb,
                                                  data:
                                                      *mut c_void);
    pub fn evas_obj_image_data_copy_set(data: *mut c_void);
    pub fn evas_obj_image_animated_frame_set(frame_index:
                                                 c_int);
    pub fn evas_obj_image_region_support_get() -> EinaBool;
    pub fn evas_obj_image_load_error_get() -> EvasLoadError;
    pub fn evas_obj_image_animated_frame_count_get() -> c_int;
    pub fn evas_obj_image_stride_get() -> c_int;
    pub fn evas_obj_image_animated_loop_type_get()
     -> EvasImageAnimatedLoopHint;
    pub fn evas_obj_image_animated_loop_count_get() -> c_int;
    pub fn evas_obj_image_scene_set(scene: *mut EvasCanvas3DScene);
    pub fn evas_obj_image_scene_get() -> *mut EvasCanvas3DScene;
    pub fn evas_obj_image_orient_set(orient: EvasImageOrient);
    pub fn evas_obj_image_orient_get() -> EvasImageOrient;
    pub fn evas_obj_image_snapshot_set(s: EinaBool);
    pub fn evas_obj_image_snapshot_get() -> EinaBool;
    pub fn evas_obj_image_preload_begin();
    pub fn evas_obj_image_data_update_add(x: c_int,
                                          y: c_int,
                                          w: c_int,
                                          h: c_int);
    pub fn evas_obj_image_animated_frame_duration_get(start_frame:
                                                          c_int,
                                                      frame_num:
                                                          c_int)
     -> c_double;
    pub fn evas_obj_image_data_set(data: *mut c_void);
    pub fn evas_obj_image_data_get(for_writing: EinaBool)
     -> *mut c_void;
    pub fn evas_obj_image_preload_cancel();
    pub fn evas_vg_class_get() -> *const EoClass;
    pub fn evas_obj_vg_root_node_get() -> *mut EflVg;
    pub fn efl_vg_base_class_get() -> *const EoClass;
    pub fn efl_vg_bounds_get(r: *mut EinaRectangle);
    pub fn efl_vg_name_set(name: *const c_char);
    pub fn efl_vg_name_get() -> *const c_char;
    pub fn efl_vg_transformation_set(m: *const EinaMatrix3);
    pub fn efl_vg_transformation_get() -> *const EinaMatrix3;
    pub fn efl_vg_origin_set(x: c_double,
                             y: c_double);
    pub fn efl_vg_origin_get(x: *mut c_double,
                             y: *mut c_double);
    pub fn efl_vg_mask_set(m: *mut EflVg);
    pub fn efl_vg_mask_get() -> *mut EflVg;
    pub fn efl_vg_interpolate(from: *const EflVgBase,
                              to: *const EflVgBase,
                              pos_map: c_double) -> EinaBool;
    pub fn efl_vg_dup(from: *const EflVgBase);
    pub fn efl_vg_container_class_get() -> *const EoClass;
    pub fn efl_vg_container_child_get(name: *const c_char)
     -> *mut EflVgBase;
    pub fn efl_vg_container_children_get() -> *mut EinaIterator;
    pub fn efl_vg_shape_class_get() -> *const EoClass;
    pub fn efl_vg_shape_fill_set(f: *mut EflVg);
    pub fn efl_vg_shape_fill_get() -> *mut EflVg;
    pub fn efl_vg_shape_stroke_fill_set(f: *mut EflVg);
    pub fn efl_vg_shape_stroke_fill_get() -> *mut EflVg;
    pub fn efl_vg_shape_stroke_marker_set(m: *mut EflVg);
    pub fn efl_vg_shape_stroke_marker_get() -> *mut EflVg;
    pub fn efl_vg_gradient_class_get() -> *const EoClass;
    pub fn efl_vg_gradient_linear_class_get() -> *const EoClass;
    pub fn efl_vg_gradient_radial_class_get() -> *const EoClass;
}
