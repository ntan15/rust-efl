#![allow(non_camel_case_types)]
extern crate libc;
extern crate eina_sys;
extern crate emile_sys;

use libc::*;
use eina_sys::*;
use emile_sys::*;
/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct Eet_Version {
    pub major: c_int,
    pub minor: c_int,
    pub micro: c_int,
    pub revision: c_int,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EetError {
    EetErrorNone = 0,
    EetErrorBadObject = 1,
    EetErrorEmpty = 2,
    EetErrorNotWritable = 3,
    EetErrorOutOfMemory = 4,
    EetErrorWriteError = 5,
    EetErrorWriteErrorFileTooBig = 6,
    EetErrorWriteErrorIoError = 7,
    EetErrorWriteErrorOutOfSpace = 8,
    EetErrorWriteErrorFileClosed = 9,
    EetErrorMmapFailed = 10,
    EetErrorX509EncodingFailed = 11,
    EetErrorSignatureFailed = 12,
    EetErrorInvalid_ignature = 13,
    EetErrorNotSigned = 14,
    EetErrorNotImplemented = 15,
    EetErrorPrngNotSeeded = 16,
    EetErrorEncryptFailed = 17,
    EetErrorDecryptFailed = 18,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EetCompression {
    EetCompressionNone = 0,
    EetCompressionDefault = 1,
    EetCompressionLow = 2,
    EetCompressionMed = 6,
    EetCompressionHi = 9,
    EetCompressionVeryfast = 10,
    EetCompressionSuperfast = 11,
    EetCompressionLow2 = 3,
    EetCompressionMed1 = 4,
    EetCompressionMed2 = 5,
    EetCompressionHi1 = 7,
    EetCompressionHi2 = 8,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
#[repr(C)]
pub enum EetFileMode {
    EetFileModeInvalid = -1,
    EetFileModeRead = 0,
    EetFileModeWrite = 1,
    EetFileModeReadWrite = 2,
}
pub type EetImageEncoding = EmileImageEncoding;
pub type EetColorspace = EmileColorspace;
pub enum Eet_File { }
pub enum Eet_Dictionary { }

#[repr(C)]
pub struct Eet_Entry {
    pub name: *const c_char,
    pub offset: c_int,
    pub size: c_int,
    pub data_size: c_int,
    pub compression: EinaBool,
    pub ciphered: EinaBool,
    pub alias: EinaBool,
}

pub enum Eet_Key { }
pub type EetKeyPasswordCallback =
    Option<unsafe extern "C" fn(buffer: *mut c_char,
                                size: c_int,
                                rwflag: c_int,
                                data: *mut c_void)
                              -> c_int>;
pub enum Eet_Data_Descriptor { }
pub type EetDescriptorHashForeachCallbackCallback =
    Option<unsafe extern "C" fn(h: *mut c_void,
                                k: *const c_char,
                                dt: *mut c_void,
                                fdt: *mut c_void)
                              -> c_int>;
pub type EetDescriptorMemAllocCallback =
    Option<extern "C" fn(size: size_t)
                              -> *mut c_void>;
pub type EetDescriptorMemFreeCallback =
    Option<unsafe extern "C" fn(mem: *mut c_void)>;
pub type EetDescriptorStrAllocCallback =
    Option<unsafe extern "C" fn(str: *const c_char)
                              -> *mut c_char>;
pub type EetDescriptorStrFreeCallback =
    Option<unsafe extern "C" fn(str: *const c_char)>;
pub type EetDescriptorListNextCallback =
    Option<unsafe extern "C" fn(l: *mut c_void)
                              -> *mut c_void>;
pub type EetDescriptorListAppendCallback =
    Option<unsafe extern "C" fn(l: *mut c_void,
                                d: *mut c_void)
                              -> *mut c_void>;
pub type EetDescriptorListDataCallback =
    Option<unsafe extern "C" fn(l: *mut c_void)
                              -> *mut c_void>;
pub type EetDescriptorListFreeCallback =
    Option<unsafe extern "C" fn(l: *mut c_void)
                              -> *mut c_void>;
pub type EetDescriptorHashForeachCallback =
    Option<unsafe extern "C" fn(h: *mut c_void,
                                func: EetDescriptorHashForeachCallbackCallback,
                                fdt: *mut c_void)>;
pub type EetDescriptorHashAddCallback =
    Option<unsafe extern "C" fn(h: *mut c_void,
                                k: *const c_char,
                                d: *mut c_void)
                              -> *mut c_void>;
pub type EetDescriptorHashFreeCallback =
    Option<unsafe extern "C" fn(h: *mut c_void)>;
pub type EetDescriptorStrDirectAllocCallback =
    Option<unsafe extern "C" fn(str: *const c_char)
                              -> *mut c_char>;
pub type EetDescriptorStrDirectFreeCallback =
    Option<unsafe extern "C" fn(str:  *const c_char)>;
pub type EetDescriptorTypeGetCallback =
    Option<unsafe extern "C" fn(data: *const c_void,
                                unknow: *mut EinaBool)
                              -> *const c_char>;
pub type EetDescriptorTypeSetCallback =
    Option<unsafe extern "C" fn(_type: *const c_char,
                                data: *mut c_void,
                                unknow: EinaBool)
                              -> EinaBool>;
pub type EetDescriptorArrayAllocCallback =
    Option<extern "C" fn(size: size_t) -> *mut c_void>;
pub type EetDescriptorArrayFreeCallback =
    Option<unsafe extern "C" fn(mem: *mut c_void)>;

#[repr(C)]
pub struct Eet_Data_Descriptor_Class {
    pub version: c_int,
    pub name: *const c_char,
    pub size: c_int,
    pub func: EetStructUnnamed1,
}

#[repr(C)]
pub struct EetStructUnnamed1 {
    pub mem_alloc: EetDescriptorMemAllocCallback,
    pub mem_free: EetDescriptorMemFreeCallback,
    pub str_alloc: EetDescriptorStrAllocCallback,
    pub str_free: EetDescriptorStrFreeCallback,
    pub list_next: EetDescriptorListNextCallback,
    pub list_append: EetDescriptorListAppendCallback,
    pub list_data: EetDescriptorListDataCallback,
    pub list_free: EetDescriptorListFreeCallback,
    pub hash_foreach: EetDescriptorHashForeachCallback,
    pub hash_add: EetDescriptorHashAddCallback,
    pub hash_free: EetDescriptorHashFreeCallback,
    pub str_direct_alloc: EetDescriptorStrDirectAllocCallback,
    pub str_direct_free: EetDescriptorStrDirectFreeCallback,
    pub type_get: EetDescriptorTypeGetCallback,
    pub type_set: EetDescriptorTypeSetCallback,
    pub array_alloc: EetDescriptorArrayAllocCallback,
    pub array_free: EetDescriptorArrayFreeCallback,
}

pub type EetDumpCallback = Option<unsafe extern "C" fn(data: *mut c_void,
                                                       _str: *const c_char)>;
pub enum Eet_Node { }

#[repr(C)]
#[derive(Copy)]
pub struct Eet_Node_Data {
    pub value: EetUnionUnnamed2,
}
impl ::std::clone::Clone for Eet_Node_Data {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Eet_Node_Data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct EetUnionUnnamed2 {
    pub _bindgen_data_: [u64; 1usize],
}
impl EetUnionUnnamed2 {
    pub unsafe fn c(&mut self) -> *mut c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s(&mut self) -> *mut c_short {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn i(&mut self) -> *mut c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn l(&mut self) -> *mut c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn f(&mut self) -> *mut c_float {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn d(&mut self) -> *mut c_double {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uc(&mut self) -> *mut c_uchar {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn us(&mut self) -> *mut c_ushort {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ui(&mut self) -> *mut c_uint {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ul(&mut self) -> *mut c_ulonglong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut *const c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for EetUnionUnnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for EetUnionUnnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type EetNodeWalkStructAllocCallback =
    Option<unsafe extern "C" fn(_type: *const c_char,
                                user_data: *mut c_void)
                              -> *mut c_void>;
pub type EetNodeWalkStructAddCallback =
    Option<unsafe extern "C" fn(parent: *mut c_void,
                                name: *const c_char,
                                child: *mut c_void,
                                user_data: *mut c_void)>;
pub type EetNodeWalkArrayCallback =
    Option<unsafe extern "C" fn(variable: EinaBool,
                                name: *const c_char,
                                count: c_int,
                                user_data: *mut c_void)
                              -> *mut c_void>;
pub type EetNodeWalkInsertCallback =
    Option<unsafe extern "C" fn(array: *mut c_void,
                                index: c_int,
                                child: *mut c_void,
                                user_data: *mut c_void)>;
pub type Eet_Node_WalkListCallback =
    Option<unsafe extern "C" fn(name: *const c_char,
                                user_data: *mut c_void)
                              -> *mut c_void>;
pub type EetNodeWalkAppendCallback =
    Option<unsafe extern "C" fn(list: *mut c_void,
                                child: *mut c_void,
                                user_data: *mut c_void)>;
pub type EetNodeWalkHashCallback =
    Option<unsafe extern "C" fn(parent: *mut c_void,
                                name: *const c_char,
                                key: *const c_char,
                                value: *mut c_void,
                                user_data: *mut c_void)
                              -> *mut c_void>;
pub type EetNodeWalkSimpleCallback =
    Option<unsafe extern "C" fn(_type: c_int,
                                data: *mut Eet_Node_Data,
                                user_data: *mut c_void)
                              -> *mut c_void>;
#[repr(C)]
pub struct Eet_Node_Walk {
    pub struct_alloc: EetNodeWalkStructAllocCallback,
    pub struct_add: EetNodeWalkStructAddCallback,
    pub array: EetNodeWalkArrayCallback,
    pub insert: EetNodeWalkInsertCallback,
    pub list: Eet_Node_WalkListCallback,
    pub append: EetNodeWalkAppendCallback,
    pub hash: EetNodeWalkHashCallback,
    pub simple: EetNodeWalkSimpleCallback,
}

pub enum Eet_Connection { }
pub type EetReadCb = unsafe extern "C" fn(eet_data: *const c_void,
                                          size: size_t, user_data: *mut c_void)
                                          -> EinaBool;
pub type EetWriteCb = unsafe extern "C" fn(data: *const c_void, size: size_t,
                                           user_data: *mut c_void) -> EinaBool;
#[link(name = "eet")]
extern "C" {
    pub static mut eet_version: *mut Eet_Version;
}
#[link(name = "eet")]
extern "C" {
    pub fn eet_init() -> c_int;
    pub fn eet_shutdown() -> c_int;
    pub fn eet_clearcache();
    pub fn eet_open(file: *const c_char, mode: EetFileMode)
     -> *mut Eet_File;
    pub fn eet_mmap(file: *const Eina_File) -> *mut Eet_File;
    pub fn eet_memopen_read(data: *const c_void, size: size_t)
     -> *mut Eet_File;
    pub fn eet_mode_get(ef: *mut Eet_File) -> EetFileMode;
    pub fn eet_close(ef: *mut Eet_File) -> EetError;
    pub fn eet_sync(ef: *mut Eet_File) -> EetError;
    pub fn eet_dictionary_get(ef: *mut Eet_File) -> *mut Eet_Dictionary;
    pub fn eet_dictionary_string_check(ed: *mut Eet_Dictionary,
                                       string: *const c_char)
     -> c_int;
    pub fn eet_dictionary_count(ed: *const Eet_Dictionary)
     -> c_int;
    pub fn eet_read(ef: *mut Eet_File, name: *const c_char,
                    size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_read_direct(ef: *mut Eet_File,
                           name: *const c_char,
                           size_ret: *mut c_int)
     -> *const c_void;
    pub fn eet_write(ef: *mut Eet_File, name: *const c_char,
                     data: *const c_void,
                     size: c_int,
                     compress: c_int)
     -> c_int;
    pub fn eet_delete(ef: *mut Eet_File, name: *const c_char)
     -> c_int;
    pub fn eet_alias(ef: *mut Eet_File, name: *const c_char,
                     destination: *const c_char,
                     compress: c_int) -> EinaBool;
    pub fn eet_file_get(ef: *mut Eet_File) -> *const c_char;
    pub fn eet_alias_get(ef: *mut Eet_File,
                         name: *const c_char)
     -> *const c_char;
    pub fn eet_list(ef: *mut Eet_File, glob: *const c_char,
                    count_ret: *mut c_int)
     -> *mut *mut c_char;
    pub fn eet_list_entries(ef: *mut Eet_File) -> *mut Eina_Iterator;
    pub fn eet_num_entries(ef: *mut Eet_File) -> c_int;
    pub fn eet_read_cipher(ef: *mut Eet_File,
                           name: *const c_char,
                           size_ret: *mut c_int,
                           cipher_key: *const c_char)
     -> *mut c_void;
    pub fn eet_write_cipher(ef: *mut Eet_File,
                            name: *const c_char,
                            data: *const c_void,
                            size: c_int,
                            compress: c_int,
                            cipher_key: *const c_char)
     -> c_int;
    pub fn eet_data_image_header_read(ef: *mut Eet_File,
                                      name: *const c_char,
                                      w: *mut c_uint,
                                      h: *mut c_uint,
                                      alpha: *mut c_int,
                                      compress: *mut c_int,
                                      quality: *mut c_int,
                                      lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_read(ef: *mut Eet_File,
                               name: *const c_char,
                               w: *mut c_uint,
                               h: *mut c_uint,
                               alpha: *mut c_int,
                               compress: *mut c_int,
                               quality: *mut c_int,
                               lossy: *mut EetImageEncoding)
     -> *mut c_void;
    pub fn eet_data_image_read_to_surface(ef: *mut Eet_File,
                                          name: *const c_char,
                                          src_x: c_uint,
                                          src_y: c_uint,
                                          d: *mut c_uint,
                                          w: c_uint,
                                          h: c_uint,
                                          row_stride: c_uint,
                                          alpha: *mut c_int,
                                          compress: *mut c_int,
                                          quality: *mut c_int,
                                          lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_write(ef: *mut Eet_File,
                                name: *const c_char,
                                data: *const c_void,
                                w: c_uint,
                                h: c_uint,
                                alpha: c_int,
                                compress: c_int,
                                quality: c_int,
                                lossy: EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_header_decode(data: *const c_void,
                                        size: c_int,
                                        w: *mut c_uint,
                                        h: *mut c_uint,
                                        alpha: *mut c_int,
                                        compress: *mut c_int,
                                        quality: *mut c_int,
                                        lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_decode(data: *const c_void,
                                 size: c_int,
                                 w: *mut c_uint,
                                 h: *mut c_uint,
                                 alpha: *mut c_int,
                                 compress: *mut c_int,
                                 quality: *mut c_int,
                                 lossy: *mut EetImageEncoding)
     -> *mut c_void;
    pub fn eet_data_image_decode_to_surface(data: *const c_void,
                                            size: c_int,
                                            src_x: c_uint,
                                            src_y: c_uint,
                                            d: *mut c_uint,
                                            w: c_uint,
                                            h: c_uint,
                                            row_stride: c_uint,
                                            alpha: *mut c_int,
                                            compress: *mut c_int,
                                            quality: *mut c_int,
                                            lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_encode(data: *const c_void,
                                 size_ret: *mut c_int,
                                 w: c_uint,
                                 h: c_uint,
                                 alpha: c_int,
                                 compress: c_int,
                                 quality: c_int,
                                 lossy: EetImageEncoding)
     -> *mut c_void;
    pub fn eet_data_image_header_read_cipher(ef: *mut Eet_File,
                                             name: *const c_char,
                                             cipher_key: *const c_char,
                                             w: *mut c_uint,
                                             h: *mut c_uint,
                                             alpha: *mut c_int,
                                             compress: *mut c_int,
                                             quality: *mut c_int,
                                             lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_colorspace_get(ef: *mut Eet_File,
                                         name: *const c_char,
                                         cipher_key: *const c_char,
                                         cspaces: *mut *const EetColorspace)
     -> c_int;
    pub fn eet_data_image_read_cipher(ef: *mut Eet_File,
                                      name: *const c_char,
                                      cipher_key: *const c_char,
                                      w: *mut c_uint,
                                      h: *mut c_uint,
                                      alpha: *mut c_int,
                                      compress: *mut c_int,
                                      quality: *mut c_int,
                                      lossy: *mut EetImageEncoding)
     -> *mut c_void;
    pub fn eet_data_image_read_to_surface_cipher(ef: *mut Eet_File,
                                                 name: *const c_char,
                                                 cipher_key: *const c_char,
                                                 src_x: c_uint,
                                                 src_y: c_uint,
                                                 d: *mut c_uint,
                                                 w: c_uint,
                                                 h: c_uint,
                                                 row_stride: c_uint,
                                                 alpha: *mut c_int,
                                                 compress: *mut c_int,
                                                 quality: *mut c_int,
                                                 lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_read_to_cspace_surface_cipher(ef: *mut Eet_File,
                                                        name: *const c_char,
                                                        cipher_key: *const c_char,
                                                        src_x: c_uint,
                                                        src_y: c_uint,
                                                        d: *mut c_uint,
                                                        w: c_uint,
                                                        h: c_uint,
                                                        row_stride: c_uint,
                                                        cspace: EetColorspace,
                                                        alpha: *mut c_int,
                                                        comp: *mut c_int,
                                                        quality: *mut c_int,
                                                        lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_decode_to_cspace_surface_cipher(data: *const c_void,
                                                          cipher_key: *const c_char,
                                                          size: c_int,
                                                          src_x: c_uint,
                                                          src_y: c_uint,
                                                          d: *mut c_uint,
                                                          w: c_uint,
                                                          h: c_uint,
                                                          row_stride: c_uint,
                                                          cspace: EetColorspace,
                                                          alpha: *mut c_int,
                                                          comp: *mut c_int,
                                                          quality: *mut c_int,
                                                          lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_write_cipher(ef: *mut Eet_File,
                                       name: *const c_char,
                                       cipher_key: *const c_char,
                                       data: *const c_void,
                                       w: c_uint,
                                       h: c_uint,
                                       alpha: c_int,
                                       compress: c_int,
                                       quality: c_int,
                                       lossy: EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_header_decode_cipher(data: *const c_void,
                                               cipher_key: *const c_char,
                                               size: c_int,
                                               w: *mut c_uint,
                                               h: *mut c_uint,
                                               alpha: *mut c_int,
                                               compress: *mut c_int,
                                               quality: *mut c_int,
                                               lossy: *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_decode_cipher(data: *const c_void,
                                        cipher_key:
                                            *const c_char,
                                        size: c_int,
                                        w: *mut c_uint,
                                        h: *mut c_uint,
                                        alpha: *mut c_int,
                                        compress: *mut c_int,
                                        quality: *mut c_int,
                                        lossy: *mut EetImageEncoding)
     -> *mut c_void;
    pub fn eet_data_image_decode_to_surface_cipher(data:
                                                       *const c_void,
                                                   cipher_key:
                                                       *const c_char,
                                                   size:
                                                       c_int,
                                                   src_x:
                                                       c_uint,
                                                   src_y:
                                                       c_uint,
                                                   d:
                                                       *mut c_uint,
                                                   w: c_uint,
                                                   h: c_uint,
                                                   row_stride:
                                                       c_uint,
                                                   alpha:
                                                       *mut c_int,
                                                   compress:
                                                       *mut c_int,
                                                   quality:
                                                       *mut c_int,
                                                   lossy:
                                                       *mut EetImageEncoding)
     -> c_int;
    pub fn eet_data_image_encode_cipher(data: *const c_void,
                                        cipher_key:
                                            *const c_char,
                                        w: c_uint,
                                        h: c_uint,
                                        alpha: c_int,
                                        compress: c_int,
                                        quality: c_int,
                                        lossy: EetImageEncoding,
                                        size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_identity_open(certificate_file: *const c_char,
                             private_key_file: *const c_char,
                             cb: EetKeyPasswordCallback) -> *mut Eet_Key;
    pub fn eet_identity_close(key: *mut Eet_Key);
    pub fn eet_identity_set(ef: *mut Eet_File, key: *mut Eet_Key)
     -> EetError;
    pub fn eet_identity_print(key: *mut Eet_Key, out: *mut FILE);
    pub fn eet_identity_verify(ef: *mut Eet_File,
                               certificate_file:
                                   *const c_char)
     -> EinaBool;
    pub fn eet_identity_x509(ef: *mut Eet_File,
                             der_length: *mut c_int)
     -> *const c_void;
    pub fn eet_identity_signature(ef: *mut Eet_File,
                                  signature_length:
                                      *mut c_int)
     -> *const c_void;
    pub fn eet_identity_sha1(ef: *mut Eet_File,
                             sha1_length: *mut c_int)
     -> *const c_void;
    pub fn eet_identity_certificate_print(certificate:
                                              *const c_uchar,
                                          der_length: c_int,
                                          out: *mut FILE);
    pub fn eet_data_descriptor_new(name: *const c_char,
                                   size: c_int,
                                   func_list_next:
                                       EetDescriptorListNextCallback,
                                   func_list_append:
                                       EetDescriptorListAppendCallback,
                                   func_list_data:
                                       EetDescriptorListDataCallback,
                                   func_list_free:
                                       EetDescriptorListFreeCallback,
                                   func_hash_foreach:
                                       EetDescriptorHashForeachCallback,
                                   func_hash_add:
                                       EetDescriptorHashAddCallback,
                                   func_hash_free:
                                       EetDescriptorHashFreeCallback)
     -> *mut Eet_Data_Descriptor;
    pub fn eet_data_descriptor2_new(eddc: *const Eet_Data_Descriptor_Class)
     -> *mut Eet_Data_Descriptor;
    pub fn eet_data_descriptor3_new(eddc: *const Eet_Data_Descriptor_Class)
     -> *mut Eet_Data_Descriptor;
    pub fn eet_data_descriptor_stream_new(eddc:
                                              *const Eet_Data_Descriptor_Class)
     -> *mut Eet_Data_Descriptor;
    pub fn eet_data_descriptor_file_new(eddc:
                                            *const Eet_Data_Descriptor_Class)
     -> *mut Eet_Data_Descriptor;
    pub fn eet_eina_stream_data_descriptor_class_set(eddc:
                                                         *mut Eet_Data_Descriptor_Class,
                                                     eddc_size:
                                                         c_uint,
                                                     name:
                                                         *const c_char,
                                                     size:
                                                         c_int)
     -> EinaBool;
    pub fn eet_eina_file_data_descriptor_class_set(eddc:
                                                       *mut Eet_Data_Descriptor_Class,
                                                   eddc_size:
                                                       c_uint,
                                                   name:
                                                       *const c_char,
                                                   size:
                                                       c_int)
     -> EinaBool;
    pub fn eet_data_descriptor_free(edd: *mut Eet_Data_Descriptor);
    pub fn eet_data_descriptor_name_get(edd: *const Eet_Data_Descriptor)
     -> *const c_char;
    pub fn eet_data_descriptor_element_add(edd: *mut Eet_Data_Descriptor,
                                           name:
                                               *const c_char,
                                           _type: c_int,
                                           group_type: c_int,
                                           offset: c_int,
                                           count: c_int,
                                           counter_name:
                                               *const c_char,
                                           subtype: *mut Eet_Data_Descriptor);
    pub fn eet_data_read(ef: *mut Eet_File, edd: *mut Eet_Data_Descriptor,
                         name: *const c_char)
     -> *mut c_void;
    pub fn eet_data_write(ef: *mut Eet_File, edd: *mut Eet_Data_Descriptor,
                          name: *const c_char,
                          data: *const c_void,
                          compress: c_int)
     -> c_int;
    pub fn eet_data_text_dump(data_in: *const c_void,
                              size_in: c_int,
                              dumpfunc: EetDumpCallback,
                              dumpdata: *mut c_void)
     -> c_int;
    pub fn eet_data_text_undump(text: *const c_char,
                                textlen: c_int,
                                size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_data_dump(ef: *mut Eet_File,
                         name: *const c_char,
                         dumpfunc: EetDumpCallback,
                         dumpdata: *mut c_void)
     -> c_int;
    pub fn eet_data_undump(ef: *mut Eet_File,
                           name: *const c_char,
                           text: *const c_char,
                           textlen: c_int,
                           compress: c_int)
     -> c_int;
    pub fn eet_data_descriptor_decode(edd: *mut Eet_Data_Descriptor,
                                      data_in: *const c_void,
                                      size_in: c_int)
     -> *mut c_void;
    pub fn eet_data_descriptor_encode(edd: *mut Eet_Data_Descriptor,
                                      data_in: *const c_void,
                                      size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_data_read_cipher(ef: *mut Eet_File,
                                edd: *mut Eet_Data_Descriptor,
                                name: *const c_char,
                                cipher_key: *const c_char)
     -> *mut c_void;
    pub fn eet_data_read_cipher_buffer(ef: *mut Eet_File,
                                       edd: *mut Eet_Data_Descriptor,
                                       name: *const c_char,
                                       cipher_key:
                                           *const c_char,
                                       buffer: *mut c_char,
                                       buffer_size: c_int)
     -> *mut c_void;
    pub fn eet_data_xattr_cipher_get(filename: *const c_char,
                                     attribute: *const c_char,
                                     edd: *mut Eet_Data_Descriptor,
                                     cipher_key:
                                         *const c_char)
     -> *mut c_void;
    pub fn eet_data_write_cipher(ef: *mut Eet_File,
                                 edd: *mut Eet_Data_Descriptor,
                                 name: *const c_char,
                                 cipher_key: *const c_char,
                                 data: *const c_void,
                                 compress: c_int)
     -> c_int;
    pub fn eet_data_xattr_cipher_set(filename: *const c_char,
                                     attribute: *const c_char,
                                     edd: *mut Eet_Data_Descriptor,
                                     cipher_key:
                                         *const c_char,
                                     data: *const c_void,
                                     flags: EinaXattrFlags) -> EinaBool;
    pub fn eet_data_text_dump_cipher(data_in: *const c_void,
                                     cipher_key:
                                         *const c_char,
                                     size_in: c_int,
                                     dumpfunc: EetDumpCallback,
                                     dumpdata: *mut c_void)
     -> c_int;
    pub fn eet_data_text_undump_cipher(text: *const c_char,
                                       cipher_key:
                                           *const c_char,
                                       textlen: c_int,
                                       size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_data_dump_cipher(ef: *mut Eet_File,
                                name: *const c_char,
                                cipher_key: *const c_char,
                                dumpfunc: EetDumpCallback,
                                dumpdata: *mut c_void)
     -> c_int;
    pub fn eet_data_undump_cipher(ef: *mut Eet_File,
                                  name: *const c_char,
                                  cipher_key: *const c_char,
                                  text: *const c_char,
                                  textlen: c_int,
                                  compress: c_int)
     -> c_int;
    pub fn eet_data_descriptor_decode_cipher(edd: *mut Eet_Data_Descriptor,
                                             data_in:
                                                 *const c_void,
                                             cipher_key:
                                                 *const c_char,
                                             size_in: c_int)
     -> *mut c_void;
    pub fn eet_data_descriptor_encode_cipher(edd: *mut Eet_Data_Descriptor,
                                             data_in:
                                                 *const c_void,
                                             cipher_key:
                                                 *const c_char,
                                             size_ret:
                                                 *mut c_int)
     -> *mut c_void;
    pub fn eet_node_char_new(name: *const c_char,
                             c: c_char) -> *mut Eet_Node;
    pub fn eet_node_short_new(name: *const c_char,
                              s: c_short) -> *mut Eet_Node;
    pub fn eet_node_int_new(name: *const c_char,
                            i: c_int) -> *mut Eet_Node;
    pub fn eet_node_long_long_new(name: *const c_char,
                                  l: c_longlong)
     -> *mut Eet_Node;
    pub fn eet_node_float_new(name: *const c_char,
                              f: c_float) -> *mut Eet_Node;
    pub fn eet_node_double_new(name: *const c_char,
                               d: c_double) -> *mut Eet_Node;
    pub fn eet_node_unsigned_char_new(name: *const c_char,
                                      uc: c_uchar)
     -> *mut Eet_Node;
    pub fn eet_node_unsigned_short_new(name: *const c_char,
                                       us: c_ushort)
     -> *mut Eet_Node;
    pub fn eet_node_unsigned_int_new(name: *const c_char,
                                     ui: c_uint)
     -> *mut Eet_Node;
    pub fn eet_node_unsigned_long_long_new(name:
                                               *const c_char,
                                           l: c_ulonglong)
     -> *mut Eet_Node;
    pub fn eet_node_string_new(name: *const c_char,
                               str: *const c_char)
     -> *mut Eet_Node;
    pub fn eet_node_inlined_string_new(name: *const c_char,
                                       str: *const c_char)
     -> *mut Eet_Node;
    pub fn eet_node_null_new(name: *const c_char)
     -> *mut Eet_Node;
    pub fn eet_node_list_new(name: *const c_char,
                             nodes: *mut Eina_List) -> *mut Eet_Node;
    pub fn eet_node_array_new(name: *const c_char,
                              count: c_int,
                              nodes: *mut Eina_List) -> *mut Eet_Node;
    pub fn eet_node_var_array_new(name: *const c_char,
                                  nodes: *mut Eina_List) -> *mut Eet_Node;
    pub fn eet_node_hash_new(name: *const c_char,
                             key: *const c_char,
                             node: *mut Eet_Node) -> *mut Eet_Node;
    pub fn eet_node_struct_new(name: *const c_char,
                               nodes: *mut Eina_List) -> *mut Eet_Node;
    pub fn eet_node_struct_child_new(parent: *const c_char,
                                     child: *mut Eet_Node) -> *mut Eet_Node;
    pub fn eet_node_children_get(node: *mut Eet_Node) -> *mut Eet_Node;
    pub fn eet_node_next_get(node: *mut Eet_Node) -> *mut Eet_Node;
    pub fn eet_node_parent_get(node: *mut Eet_Node) -> *mut Eet_Node;
    pub fn eet_node_list_append(parent: *mut Eet_Node,
                                name: *const c_char,
                                child: *mut Eet_Node);
    pub fn eet_node_struct_append(parent: *mut Eet_Node,
                                  name: *const c_char,
                                  child: *mut Eet_Node);
    pub fn eet_node_hash_add(parent: *mut Eet_Node,
                             name: *const c_char,
                             key: *const c_char,
                             child: *mut Eet_Node);
    pub fn eet_node_dump(n: *mut Eet_Node, dumplevel: c_int,
                         dumpfunc: EetDumpCallback,
                         dumpdata: *mut c_void);
    pub fn eet_node_type_get(node: *mut Eet_Node) -> c_int;
    pub fn eet_node_value_get(node: *mut Eet_Node) -> *mut Eet_Node_Data;
    pub fn eet_node_del(n: *mut Eet_Node);
    pub fn eet_data_node_encode_cipher(node: *mut Eet_Node,
                                       cipher_key:
                                           *const c_char,
                                       size_ret: *mut c_int)
     -> *mut c_void;
    pub fn eet_data_node_decode_cipher(data_in: *const c_void,
                                       cipher_key:
                                           *const c_char,
                                       size_in: c_int)
     -> *mut Eet_Node;
    pub fn eet_data_node_read_cipher(ef: *mut Eet_File,
                                     name: *const c_char,
                                     cipher_key:
                                         *const c_char)
     -> *mut Eet_Node;
    pub fn eet_data_node_write_cipher(ef: *mut Eet_File,
                                      name: *const c_char,
                                      cipher_key:
                                          *const c_char,
                                      node: *mut Eet_Node,
                                      compress: c_int)
     -> c_int;
    pub fn eet_node_walk(parent: *mut c_void,
                         name: *const c_char,
                         root: *mut Eet_Node, cb: *mut Eet_Node_Walk,
                         user_data: *mut c_void)
     -> *mut c_void;
    pub fn eet_connection_new(eet_read_cb: *mut Option<extern "C" fn() -> EinaBool>,
                              eet_write_cb: *mut Option<extern "C" fn() -> EinaBool>,
                              user_data: *const c_void)
     -> *mut Eet_Connection;
    pub fn eet_connection_received(conn: *mut Eet_Connection,
                                   data: *const c_void,
                                   size: size_t) -> c_int;
    pub fn eet_connection_empty(conn: *mut Eet_Connection) -> EinaBool;
    pub fn eet_connection_send(conn: *mut Eet_Connection,
                               edd: *mut Eet_Data_Descriptor,
                               data_in: *const c_void,
                               cipher_key: *const c_char)
     -> EinaBool;
    pub fn eet_connection_node_send(conn: *mut Eet_Connection,
                                    node: *mut Eet_Node,
                                    cipher_key: *const c_char)
     -> EinaBool;
    pub fn eet_connection_close(conn: *mut Eet_Connection,
                                on_going: *mut EinaBool)
     -> *mut c_void;
}
